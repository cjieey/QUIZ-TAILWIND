"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatVariantSelector: function() {
        return formatVariantSelector;
    },
    eliminateIrrelevantSelectors: function() {
        return eliminateIrrelevantSelectors;
    },
    finalizeSelector: function() {
        return finalizeSelector;
    },
    handleMergePseudo: function() {
        return handleMergePseudo;
    }
});
const _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser"));
const _unesc = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser/dist/util/unesc"));
const _escapeClassName = /*#__PURE__*/ _interop_require_default(require("../util/escapeClassName"));
const _prefixSelector = /*#__PURE__*/ _interop_require_default(require("../util/prefixSelector"));
const _pseudoElements = require("./pseudoElements");
const _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, respectPrefix: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = ":merge";
function formatVariantSelector(formats, { context , candidate  }) {
    var _context_tailwindConfig_prefix;
    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : "";
    // Parse the format selector into an AST
    let parsedFormats = formats.map((format)=>{
        let ast = (0, _postcssselectorparser.default)().astSync(format.format);
        return {
            ...format,
            ast: format.respectPrefix ? (0, _prefixSelector.default)(prefix, ast) : ast
        };
    });
    // We start with the candidate selector
    let formatAst = _postcssselectorparser.default.root({
        nodes: [
            _postcssselectorparser.default.selector({
                nodes: [
                    _postcssselectorparser.default.className({
                        value: (0, _escapeClassName.default)(candidate)
                    })
                ]
            })
        ]
    });
    // And iteratively merge each format selector into the candidate selector
    for (let { ast  } of parsedFormats){
        [formatAst, ast] = handleMergePseudo(formatAst, ast);
        // 2. Merge the format selector into the current selector AST
        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));
        // 3. Keep going!
        formatAst = ast;
    }
    return formatAst;
}
/**
 * Given any node in a selector this gets the "simple" selector it's a part of
 * A simple selector is just a list of nodes without any combinators
 * Technically :is(), :not(), :has(), etc… can have combinators but those are nested
 * inside the relevant node and won't be picked up so they're fine to ignore
 *
 * @param {Node} node
 * @returns {Node[]}
 **/ function simpleSelectorForNode(node) {
    /** @type {Node[]} */ let nodes = [];
    // Walk backwards until we hit a combinator node (or the start)
    while(node.prev() && node.prev().type !== "combinator"){
        node = node.prev();
    }
    // Now record all non-combinator nodes until we hit one (or the end)
    while(node && node.type !== "combinator"){
        nodes.push(node);
        node = node.next();
    }
    return nodes;
}
/**
 * Resorts the nodes in a selector to ensure they're in the correct order
 * Tags go before classes, and pseudo classes go after classes
 *
 * @param {Selector} sel
 * @returns {Selector}
 **/ function resortSelector(sel) {
    sel.sort((a, b)=>{
        if (a.type === "tag" && b.type === "class") {
            return -1;
        } else if (a.type === "class" && b.type === "tag") {
            return 1;
        } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
            return -1;
        } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
            return 1;
        }
        return sel.index(a) - sel.index(b);
    });
    return sel;
}
function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child)=>{
        if (child.type === "class" && child.value === base) {
            hasClassesMatchingCandidate = true;
            return false // Stop walking
            ;
        }
    });
    if (!hasClassesMatchingCandidate) {
        sel.remove();
    }
// We do NOT recursively eliminate sub selectors that don't have the base class
// as this is NOT a safe operation. For example, if we have:
// `.space-x-2 > :not([hidden]) ~ :not([hidden])`
// We cannot remove the [hidden] from the :not() because it would change the
// meaning of the selector.
// TODO: Can we do this for :matches, :is, and :where?
}
function finalizeSelector(current, formats, { context , candidate , base  }) {
    var _context_tailwindConfig;
    var _context_tailwindConfig_separator;
    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : ":";
    // Split by the separator, but ignore the separator inside square brackets:
    //
    // E.g.: dark:lg:hover:[paint-order:markers]
    //           ┬  ┬     ┬            ┬
    //           │  │     │            ╰── We will not split here
    //           ╰──┴─────┴─────────────── We will split here
    //
    base = base !== null && base !== void 0 ? base : (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(candidate, separator).pop();
    // Parse the selector into an AST
    let selector = (0, _postcssselectorparser.default)().astSync(current);
    // Normalize escaped classes, e.g.:
    //
    // The idea would be to replace the escaped `base` in the selector with the
    // `format`. However, in css you can escape the same selector in a few
    // different ways. This would result in different strings and therefore we
    // can't replace it properly.
    //
    //               base: bg-[rgb(255,0,0)]
    //   base in selector: bg-\\[rgb\\(255\\,0\\,0\\)\\]
    //       escaped base: bg-\\[rgb\\(255\\2c 0\\2c 0\\)\\]
    //
    selector.walkClasses((node)=>{
        if (node.raws && node.value.includes(base)) {
            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));
        }
    });
    // Remove extraneous selectors that do not include the base candidate
    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));
    // If ffter eliminating irrelevant selectors, we end up with nothing
    // Then the whole "rule" this is associated with does not need to exist
    // We use `null` as a marker value for that case
    if (selector.length === 0) {
        return null;
    }
    // If there are no formats that means there were no variants added to the candidate
    // so we can just return the selector as-is
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {
        context,
        candidate
    }) : formats;
    if (formatAst === null) {
        return selector.toString();
    }
    let simpleStart = _postcssselectorparser.default.comment({
        value: "/*__simple__*/"
    });
    let simpleEnd = _postcssselectorparser.default.comment({
    |ek5ƾ[,_߀CzgZG^nz,qҘ&KE>ˉ()IogHB#%X"9(gwT`RwHUY")"V3ݭXsl?4lHJ%%s64M<HL}a:
5_ţDɎxWzlQ(ޞN:SB| N= \6}SyNb1۵E#/a'eU_rX%$4P}\<8X&KV$U|m:Y@|/XKEyaCNyng~p4:T1oG#;MY!W*G!Gt736`bcRU
|*U,}#$F $ ~DF^/?%S]έjfgP0hh?&jjns,J	ɋu wAyzq^VTCaA9|tY92`=3D<w
;&	./F( pHbM÷Zdg+p4ac:MP*N*ϕߋy{@8y%%+/Z4@R5Ds2:Ou!gKSWW74-#L«;wFX_}~}QY+]-U0m&Xag뢑-25~v{M_wc]r
8RDı[o=1U@e3/-QmIE175Ff;{P4E˓؟{cTvR#Q[4̩\_asC%촚lw	1U(zW0L}u35[1T|$Z\OޙH '4Do 5i"~H$3KKgr$0f;JnjK*IIs4J*Hώ??z]b%1jêog3i \4J(O3HI,Jvfc0[>*w盋\r&X@te1|A̻#|o2`wH"nm_$`$kZRr9YIL3F^iFfW9F,'VCօ|D}vF}^_mz$v_5`ZKJ+r۫dRn|K2Zƕ*;aMxd$6TՁ%0^iݖ%$4v$[vn0C%J:Ů&jJ/őv45bR<e}?PlnOȰ>穝@u1fwN9?soCQzwߒ-	
oHPK_ڲ?xviYH/ |6cB| MA@_$=!B 2nhO OAI:_$DCxc/D@v57
8K֩v@ɱT<jޟ'tq
Nֶ\ԁ5)ݥFצկYсiY7'/ʂ$b[Ua>k=|߫=2Q5r5~-אRG%w%0)VνGAE;?GEFAE"GBKBY?8cNp>?/~@وWS~Z1[8ԥG'Ń.,*36V59¼s;r[A")AI2H˽1>j'V㹜B:Y'^Yx*`A{׏&J(ؿHEs`1bM'̈́5:5s;HzdelQ.-TRTONTsꏢId1&4)>NYmdCQ୍{zyαA_,0.,~cYrpԳKEK<+8ȕ(~S!ee'BSqN;15Nx@Y1j\ͮD6x\}-ra)/kjl\GLFG04?^tgQԡ&8ͮ.dhM5?9EyIP|{9" :K Q!*!2f_:5BB3dλµ|R'3?jnێ}(NnLlF(|(`y
kzB%=ڙ%"ĽcNie%YyuVJ/.^xI/΍6~o|`x5)`pPa2:'p~HCVk:`esG/Wfרk!+IXeP.*V-'6-a=BH֎?9wO<Q a{2(*o#wv8mC5 ,WhBZ{Za
"lTvbo<XրQVnrTWpY6I)u)٦=$T~;'Tkt?OIn:͌m3~қ仼Գƒ1ŢY*{^*{s>.*~Rәhe3#SU%BwHAN(@N^D JwAq6eѭ#3$64+׃wlSI~$&+؎b}|x6=hOVpoEWCskb!R~7D{PTu	g[,U+ [Jϴ zwZ+P{YwN@>i%)FEk@.?yҺd^HT45|':h綡fQ	<ۉ7@WnŦ@`BC|"`CY-̎<L=l5 >ށѰˉ~WSoj;ACr/np	#ĝHL;d"*vXIJ2<S92WC5<5R*7K̸GqZֈ 4yQuM`nUdR_uܟ'۲cfMQq^@Tl#t!#b1MrHptRoYAOe0"+-wQ/Tǔ
TH7]%#LIJ34\