'use strict'

let Declaration = require('./declaration')
let tokenizer = require('./tokenize')
let Comment = require('./comment')
let AtRule = require('./at-rule')
let Root = require('./root')
let Rule = require('./rule')

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let token, type, prev
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().indexOf('!') === 0 && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().indexOf('!') === 0) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      =¢+÷Ècô»u-öJ”·…}ªo`õO•1´ñ×ìúâ…ÚôÂûB"İÁìH‹’“iıÛ!#}x|ßú¬îd×‡ vË^lU¦ »$‘Dêzí |‘µ÷}µàÈÙœku±ÊuÔÑZó)ì½oYO­ŒƒÌQcá‡›xJÓxÎw~ëq ¢ÖD”X Ÿ,BcÚ¿
ôcxòX ÆÕî´©€heˆè‰(öT ÖV_T‹[k¢¶š'óÒ«[»TØ[a›–Š¼Â?ß¸X†*‹uø]3‘õz©²Éõ£ÄA§ŞªbQ²ù¢ ï=€XÉ¸Kòİ‰¿; öÒ!^&$« qÛ*œïJ]’›Ü6½Z˜„óï;ìÎe<[ùô/0_ìùã¹f‘Æ<¬›ØÁê›áNÏô2¶`U¡ağD­myÔô	÷Ç‰¾8¹œn-ÎbÍV'¥:œÌhnšt¿“ßtEî½ÃÁÚgä‡9Í³ŸÎ‘¡bôlòĞÀ7ïÛ÷puµÿ~šs5Läêd(Æt7+ã99rÖÂÙmQ£Êæ)ÊÙ ‘›û‡FŞ“¢ĞQ?¿Š¾m;…S+£ô˜h#rÕùš2 .Ÿìk–Noª=9#;¬‘ãEdãñô¦	I U^jóÆéEY}‹Â->r®‰2òt£C?ÅY°¹Kø hî *.s‘ú1í±iå?¾Û™¬İ¯~ÍêCárÒë’g¤wì›3¬_RšmÄô ”±‹™y ×“Ğ@/é¢ÁS¿ñ‹õRqBrïé²âQ(1’ñ¦ew
|ö9a¨$ +ÿ¨¤ŞŞÒ4éRÌ&Z¿½ øâÎ;6Q(“%kç3ú„zÃ‘ºÃÀ)hbœÚo·ÍãZ æ­<ñÀUÿ•N5¶–™B³x0³Œë‹màºÑÄ'ÜóGÛb0¤.Şğ«h9’ŞWŞºƒØkGVù^íú»A®É2âÂ6Ÿ"j7şJÌØ«î¬iAN ‡›À)’¯ãäzm‡ÒÍC6‘ùläm+G»CßG¥=ØŠ	Ÿ4¯x&}[0ıQÿ
àré7q¬ºÎóØñSgŠj,dàÃõÎØŞ+7yîš³|®èŠ4 ’x>D?Û’)+6·ÊØğJÂĞøhÎ»˜KÓœˆcd[…íî·qg_¼×ÄéÉHhê±y´(%Vò›˜lé¥õnP|4Í{ätœV1¥TÜ/óîğ¿gÂ$Ã›€ª4ãb¦U¦İIúØ|1ÙuÌ¶ñwµÍÇÍ4anó˜x›•šf f¯ƒŒ¤ğ²BxY?{^É–1höp,Lø5¿KIÃoa©å‘MÔMšşÉ&;m™‹I8Ìó{U:³Îû”ú"â.à#Ë«³Ğv°¸ÌŠ<›İ# Õa¸FT<2›Sä(Ï»ıü*6®>ÊÊˆû1ënLÎ™xë‹½~û2k´ı3ÒáŒ#R¡`Tÿ.]Aj€©&Ig‹·A	ùË¼WH2ã¿vJ2YX•zd¯ÛŞ§?Õò>K=P0#©¾ÕVe‹W­ŠÂ"§q*»Ê¾$Hƒ~AóËĞ
ªLıÅ[!³b¯Q¨äÒ(xÅËÃ–‡ŠùAê¦±}³´äŞËá£WÒ¶ÃruD.u7ÎL"»ˆu2´¥ñ©`Ê}ğøEŞªOœpÀôZ7³WÆİaq5Ábëâ%Eş+JR3šˆ³*ı³ù¾2ÜÊœd¼ãMZ}v#Vşœ Å»_È© :Èî5;¯ÏyË÷Ù¾@;²“Ç³’ ²àš~ô¿ëlƒV‹Í”ùKõ-õ¸÷|‰ë—Ö¤®Ö7ôê¦°#Œ"ÚfÉ†¨ïäÚØûY.<–ñP¯ÙRü½Û¥tXDô”—®]Ë!¼Ydm {Î·/¾‹J½ ÅÎ½Ş=OœË—61¦©—®TªU·D¯Ç—°;O2d€_bãË“¼I˜q€W°ĞÒĞ‰\¿	Ìõ2¹6ÙÇé@IÉt°øA˜Oı¶SBßO¡86˜±l]ìu=r´Ck9ñ—Úf°ƒ^z.>©£±Å»„ğ>’"'şğ¼3„‚PAæÊï»Øëğ2:‰3ùXî0‡ À]‹SÚN^`~,PÄêh~¤%³› |¤(a¤“*
ÓmÁŸ¥°9ä·¡×®2ã€ª¨ŸÃ¯ƒ…±9øìágS¢ºşHÉ«-2#’¥íš.hUr©U•‚;ôJËµ×Š²âùØA>u²°ĞeÙé5ƒ¥8š$.EÈµ©mÜ$¢feõ_œKÊâË`ú¿‘å“9fİïÊzšT€‘my™’À³0yC-¯Æš£j“ÉÏãËYMPü~â¨xs6nÊ¯X<Ö7°Œ™kh¬GäÉrpWEÖ~‚	ãÃX¬p¯Äõz}¬e´Ø7jáï>ôç~ñ2ˆİ”e»„œÿ3 H»8?w2Ä.×Ûµ3
È,Çœ:Úg´/8cJã3ÚQØZvFÚµ€ÊÃ€ÙâJµ”{"zl•³u`wßúÇæ"!o8ãÎRXD"°ëä
¹*Ùñ.ˆX‚U”Ç®ÖùÃYQèœÕpÅø3~¦`Ğ†ïİ[¿Õ½%hµfªå—İjÚo9E/Àä:¼`ØÂŒo'Í‘áğ5@êí_Jp@m0
^°® ‚H‚ü3xÅ%
+'Cİi;ŠŞe(²æ°èÀ-ÃaÎˆ'çên“„ÉfrñÓGÕç=–‰ñÇW)4[Ü¥z[k8‹a•µ/tÜ?ÑDgq“….1«tèOùóºÍ~v…MiıÅ“TqèWÂVX›“ñßæ¯ú9sµŸ¨ƒH È‹†ùig]FšHnåÏ¹C|¿zW)	oØhRğ™ÙÛQpâÅ§”[íƒ©hüÇä„EÕ¯+Ípñ	³4‘#Ï­jñÈ¨®XçxÌü!§Cİu»ƒÊ…†³éûªDv*=9=6é\:ß‚_çimëu
K#?ÿ¸ÒT÷ûûåvb6š÷(Üèğ©!3õ-Vuºª#@Ühß,xç¾_çœbÔ,-T›ªY÷N"‚KüY:¿o=•ñJ—Tá|›± CÅ·w– d8y_NT hxá·oOä›¿éZg$Ò§KŸş¶[ïÎÖŒ¥Uş‰œÅ(_û6{BBfÌhWó2w ÙÒ·É˜3R•×Æ•´Ê^§MÆ¯ ëÌíC/Ê‰vÎëÏZ<ˆÆA1f<î4OÏ1íWİ³Oñ$¦›ERNÁ¨o ,ŞgnºqË¸Ë™¿f!0â‹f‹Ÿ¿#Ş‡*H Uzşş®D(µf†˜oü{C!d÷#*éôlsê§?W,éğÑ„¡YÇÛ(ŠXE‘(ÎîXsaóO0¾/ş-GˆÒèôYïá1çW¹ŸËEÙ”üq¸±~’ºû•*÷í5i¼"ÎÛ@FjæÙ9•›Ãx©"o…²ÛìßÄ9Á±ÚÏ,øñf»P?0ŞF–Qş)¢(¢êÔQØÌGëÚşq*¬¬npXìïH§Q¦ecÛ…·[N´´™#¦(J…#ñ*zÚªßg—™áğDS{z)]´«±iƒ€~‘½5J)e^Fæå;şÈ9D¯aK ‹¥ İo} ¶õÎ¯L‚œnYŒ:$&ğ#¤ûÜz5èp«ÀÖë516¥~—s#§a8§½¡VR®[±%#]ó}3Èêİ/¤—Låé™4BiY¦Ûª9ÂúR² F=j?+hx3ä'·1(Åòİ¤3@«(„ñE½]tŠœûí’3U˜‡µß£éi²,¦Ü)`²™Í¥ÑvkqØ!&}hÙXS`AD<W~>Ø¾§Ä§n²
´õ!?„·°ŞÊzwKÌôrÅ&~¸+ ,ÍEÊ8u¦v‹r°XŠ<»¢½,·ˆÁ×ø™QÈ·ÆÑ&'§œÍğ¥h@5qk‹/+İivœ!Éj†NĞ”}Ğ–~¯GŞE“V=ƒ§Kò¬1„÷AÂMğÄF³DlÉ¤Š#P/‘ÊûDV.µñßáÑÀĞÊ÷¼²äŞ_¿Ê‹ô]69äµ9IÍä±uwf,ÔÕGÙüÛ.Á`Û}®ğ *­ü#pCåáÛ½EbpE­xñ-bBğ!˜3|öO{{Óg‰¨Íç„ÄÌß„ƒîá­mS^Ú6œô5=Ù‘)38H´ ?Ü÷J¾^zbdAÖ	;2PŠUúã¡¾~>·qîI£úÜ·ûf¯±Í¤ÊÄ§™üœ¨K­äš¿ÿùùO‡Ğó)f//%MùzIÑTy!7‹ÁÀïşÃÖGX·NÂÚJÔtC¶kçL¥-šÅ.)MÍh%ÜH„!¿ˆÑLÆptBh'B¡J)«Ç«v½ıcØRÊüõEæajºi˜dŒz§¾D ôÔ6iÑy} èƒÕy€£çÀ ÉÜgSPJ2ëì ÿ ø§Ñ ç×x¨§»¦¥Ö:ßn` CVt*rxïø×a¤èAëğK`;ÈËì˜;›â'ÆLçë½4º£/OE_÷!?; nW;LàÙ»Í±øŸ6½`B0¶
£•›ß2ı»òI_æJË‘‡ÂÎÍßúªûØŒ&ô¼cGJÒZ›ÔÍ[’×!ú¹•b9YóÔ—òN.ùİ?ÍšCNô	¨Ÿ§o“Êï±Ÿ,^ó#¯Øë·°Í"ë‹{®¿L5htçú (,‚ÒĞìS|º÷NÍ#”ÔÔ×’cN@­ Û‘yt¹wÿî¼ £{uœ¿¥
	èfî÷Íoûü;KøØ¯ğC.ıİbj4Á‚Çtç—Ì ßÜì“Iè‡Õ*<Ö…MĞ·G^.„ÃüÓ}_¶Êox‘Z1–hqı
¡yŸY(îK|ÄxJˆIOÏ	‚ \tıGÙÚëróë‚¡uç×pmCrÛ@Î¼ùİópû¼‰êfì—i±!W
5›Q©Wñ'ŠÁw¶»hrİ*Ù¨ïk4æ?©M¼‹0æ	sïeW\…:xŞ00ı'…>€Üı«–ÂÏhÔ´Ê!ƒb~~O7ÚVŒïÏòº*ÿçÔnÿ˜}|~4ƒ«Ó¤:£šoÒø2Ñ¾I*¥{ŒB^ZFtĞ–t_É“<G~‘,äÛ†õXó°,DZ•0Ò!xy BÕ¾üòmöï±ö·ã=æ9#±}xS"ÿú$;Lšğ9”ÛÄbÃ›È9kF²7÷|Ó3_´´û €¨â€‰      ôçà£?r°ªÜ (uWAU” ª¡z©ê
Š*ªè¡zMÿÀ  Á .pC „{·p\pÂµnÿÂ\ÛV§¾‡^hÚ hıÊ©5~ğöó´GïçxA‘!¡        ÿÿdÿ¡nî@8e UoÈhÛ_ÂŞ“ËGL°—Ğô;¡4Œœ7Dëÿ)PcEà±-]÷°„Á ½yr«\Mü	óã´`X"x:åÌ¾İ!ì¸‚´j&~øUØ{KoµzÊ4™—¹:Ú‡±	Ö7¤ù=öV jÿ¾¨ÆSevéşx-êtXœîGÀ":¥ì6ÃìMãzÕåºÍœ2¹")ê]•,×$µiŠm4öİç4ÁßYQ_¸jo.áI+²vødğûls€A”HÈ .İ7\Oıóäó ¶™Q¨oôlu?:Ør>H»?p°CÂØô®ÿÿíñÕ'Â äÏ‡"X:û>q$eô‘q±@æiøt75WIDà;9–•…«ÉivAŸÄ#{'êSŒêçNÑëtÃ¼u«×9Ï¸0ú˜Ş$9~~NS“ñ  ¤#/ÃÌ;ÃılÓº(œH·P—ÛVƒäKÃ?­ş9ÏC…Øµ@ÆÜF	*¡À <1L~‚FGpÂ×+.Îc œ¤
Dş?\NdCÏ¾ã­ÎÑ,ùÄıØÅ¯ØXä˜K¯4¿¹CËîºxuáv""¿[ÄXr!g&”"ú38·¡RAÎíŒ•å¤R“#ÿk@×¶|…åKèéé(ê™Èú¡G:1YEL—¡-™ª¥R¤²AÖa•­‰`î;Fòš§•²AãÏq:ëÛŠqGVêœMû[Ñ?üyÎÌÄ(7gÖÊWÂ;İ.9 É KÍ šKïúa87/÷K*u,è^n<vÕ‹|Ç#ï©õ´Ï.â7İUsKÚ¹i@+9"‰ØÙ*À_}Zš«ÅåaCÁ!·®jØew+|ZXH£ƒµÉËNl£İşv7Ôˆº: ¡»"á¬øâ¹Æ×ÿ>pîÆŒ,¶¨ÊFf¤ğÚKñ™Š+ÈŒ¬jM¦¯!«‘Å/WÅ¿Å0o@Îˆÿ“Dù9E1$ZKîŸõŞĞj@4wD^¥yÆtdçwn‚“xœ¬	Ê˜ë>|&éÀĞ¼†ôz¼y-˜ÿÆ×&/(IYfŞ5Ô…·_ãE¬Å°;ànHğÌkëwğßğÌ7¡-á´<‚"KïìÎÀœhênm˜~zŒÓHjI—¿i›=‘À2süfx6=MŒÛ+ Ãûğ€\Øë2{áµDhLo¤w/t#©[ª}L
Éré/hˆp—L‰ı•±0j¿ç±Ú…ha±»+~¯ 'ÊãsÃ²r­^}Tö#Ê,¨ğåƒã+d‡Ä^kÒGÕ§úgâeı»€ÑÉÿ‰úÍÓÉxW¿bÜ·)V¹ôÕ‚bJÈp«·ä^¥ˆrßı¡~äUùóØ[àvßÙ·½·÷šKÁşjEr,‹şúQ±ş‡¤vşŒù~0’£OàŞB­¦ 9EôÈŒêA¦5H¿™£Š._õÕİ;%â‘•`¨×,TÄçÂ$ü¹ËÆ×ªÕİ!ö_—ÃªıoâëôöÊh!(á>&Ïğé¥=ø•¯¢ü	Ôæá”–GÜF»è•Ïsê^ªÁˆ“g8á‚¢¤åÈ—ß©Ø˜¸…R8'µšçÿR'/®ö7¸Ş^9™F–Îû”ˆÚ1œwŞÇO‰ÿ—iø÷ÀóDúİˆ3¢eÒ.–É>`í€+{š&A=aW*¿Slg1ŠdAz…Où35=}ï?æ{z}(Ö¹btgP 3¹hf™ğ0±m`|úø™Çä²/Ì¬iü3™Á]ş{ÕÒºIJ…àL‘LŸ‹ûg¦º¯sË£ÄfŞWç>¹ßpcöºÏÜÈAæ@©Vğ}ûTñËûâşèRâÚâW¯<!Y_Ùrœï
˜¤ø1>nîX"9Üƒ7§ùó-Éÿš…·ÅËó|}ÕD´ªøTå|?Ïp¼¾]¸a1=ôu±^~^ñd—w\k9†“S)DÎİWĞ›€–ÆÁï_\7 ÆÅüœøˆŞ$¹3lèUÄÃÙÈú´¨Fè„z	‡È×f@£ƒ“ø¹ù)gÂì;3Üô-,…àû]ƒP™Qn]eäÛÿ¶÷3¼M‡6ˆ-#ÖHò€@• ®sDõ™Oø¨­µ®r9rGÙEOèuÆ-].E½ö¾ş•§O©Tå·€ú¾F‘yeË>‘W5¿Ã_¼RvBŸˆ"§Zò…¤S?û'œ
{íNÀ6œƒÊ‡,à Q^nÎw2Á‹XŒx™£‚z¹/¼¼ƒá(uv‚q˜ÃSÎ¦¾¥D¿	4»ò¡O¥‚1=b´İûß™…fÑl$ùE§ø<|â
÷rş¯oÃyO¢7ø†àõAÍÂ¾˜ÆïT÷½­W-¹r' ÊåO7+†WÅÓmÌoàË7r›W~sM-™d\R3åï)kñ>ì¼CYÍ4Dp’n°%ßxiYy!ÓÿÿI»Ë…û1Tg4–äPàËš‹ÂB}ZèÇA±®ÈSÄÊÅşqx¶pMkœo¹iÔ£ö2óÁäAğÀÌ÷‘èÙ: ¾Çµ*frÓsiÛ†¯RƒœÖËfJ¼[èà‡ÀË_:,ß(·Í2c×’7wâ
Mùì¨=È¯ËXCîC3U£0mqºù`ÿâªø@c,'ÂJÇ—^üü;ÌÀû(ó šüyUÍm09ı2çkÕŸNîwUö#=BÓ‰ÚG ¡K=¸ã0ÆÆÿ„>o3º˜™¼.„e­K”03†!«¡¼tZ^W Ùñµğ@Š¥øĞ_în”mv.€ €m¸úëÎS¹€¦}û|âsQü9¼ªCİàB±Øé‹!\À­2^§D›Wğ¡SÑ(+$ÉFº„ê«¡åvızšAÑ?Ç÷gš›Ò¿ldô—Mc“êğ*HœEvH=+iÉß_¬ù;Ûù~À©œsäËr¯-&È'ãï9UNÅÆ·M,û6§ÔŞ:iôç=B-+Ÿ[è¹üÅ´ytêÉö¡ÿì0Ûg³pd¾Oÿu²½éì²¦<ÆLPsX‡ÄÍÙ,CØCxìˆëISÔ§)tş6VHÊş³®/…