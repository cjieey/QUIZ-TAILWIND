"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(require("brace-expansion"));
const assert_valid_pattern_js_1 = require("./assert-valid-pattern.js");
const ast_js_1 = require("./ast.js");
const escape_js_1 = require("./escape.js");
const unescape_js_1 = require("./unescape.js");
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('.j)˗=7M"sY.M<d
nrwKfT(n6އK1wprX^#A6s_*wU

5IݧGPYqQ%q>qHs?EABov0QQ2\C}03U{a}p|^0I5tbtZ&Hjz#QsOWB?Jnej&hUo	p=HA>4o<8W<{fI	7]c-GJ[%t%H聏7N%*k$"HLa1bqޘvI0]м{Hc>i
L|ɦ&	eBY|Ს:@@$%"0`+=~аimXH%ͽ Gv qEy'`weuC=VS9tܬ|v&J^r-ī R#(x&!˼!g#}EV<F7d~BS‒UC$*N//`<<	);07Ւ+tAL`S4>ITgC
\ёެ/$_%=C;(\'c:(i#Z`z̸QSYs2;]V뇁,,pH:wiiāUrMBq}ؑ$Pβ>I1|(Dde'@H:j1ubָ0p%8lk %ձdF">>Ɉ;fӴ~0Ѐݰ8ڒջJoF{4axT݊,2PXV쬬'hIaZO6՜\̕$S&]Z2gQx!ݜk/D'\똌죸+z
6M Jlx̚gRf b'jz ,3IleJROBu
KSXwp.F62V+/yjCN}}2z^1U޳riC[߁@QEɖR
j.Voci~PXr>sٖ▍Ej]\kb^,DK\h̄&k̪WC츶EVZI,faym0JH6DM8㻗D}کPټ%'%^)7-vhv[Z6^$˂.PuYɳ5uTOroӡĿTw]vi͏5;

;C)',TŠJKin|y@jM~Y鈶cT|
ývk+*z4#!/-vF华ԥ]n-Z>UU4xWJfvkX:='Y3T'fBn~'hL<?NtlxP>D5[,	K֍+ӛZ~LPNMQzsY1lD"Vw4:JicݔTMaWnǷ %/M`<5ldTIZ&MM5M 2raFɑof#7 
Z6ݝ1`g*:Ăp#p:}|$E	<%Vs*Og!r蠕h*3Wyj~6v9iTRg+{g?l#)^۝9dc1BBG* @38㻲4sV[;^Z`^DvN^ġxqciXBZ>B@LQӲo+BYtPa
 $!NREٻj1ގv)]gŭgln`3}<#4výFHy-0zqAhoֱYGŶF1'ͤi܌3|@ފLZ;GXJ\KA$$a¼qh[k2gQ='y@gΦ8'%H$fy宿dEW Ȑ⫞3vXb%e/8:"AF#ڳ{)7=0T;?Ym)F@"Q DKHIϢ\QJĄp/ xT1Ie"Fa׮j3r]Rr1#{g?1=^qlD_`4KAyƭ|6hK*InL-}[E{\?D`Cvхb8l))A	6`bdWxԢb#f@@7N' ZamDR>;eg ^DF$shW]/-
Ǚg	+vR}ӛ  {4Gļmr"Rq24xiIqHW4>k?o(ת8V(f℁'kgw^}6048G5SYih4ɠ%Z \}/%ȍI X)!Wu)&@OSe@$?LqeP*)M	؉Rx{Ti$n ƽPjV!#w6q7y*̪"fOᾗ[!qMzPK6{®x'9S2Lww@"9}Qe -ečqZ%fޝ}<'i'Icf $G7f	MA+C8&Y`xB`ĬZ?_ҽXDZj6]#+(^dz6ogk6Rpt
k{߂BAVBtŐI!3=!wGȖH˻5Oq8P	iZ'~ct |JV:^t3xb i,jG!jڐt+{H1nK-@\(*a $p +.;3$G
Ԇk/G[Q㨽QzN =K(@o+=l#*e8(@Ů5FW[ 3L-zɅ@"&%
o_j.7'z1a "ȥ:|8c>㧌1CE$Љ_6l)=K{r (m8bw7-h` '(~(pzt	s$fqxKL;g^kDUm@}&P[A9[SuCbdGp̰hi\ʯwz-} rMQdT}.z d~vL0Ƃ4rm(`<fGέAyJ3)f,";4.1*R }J%nFusp3ύGFG͊'ilHaW%ᮨ֒D,U 5<xFL#g. q1gkn(}rHƒH5?,VgcG 	\Ng!?tOAB_TT=AT+D$fT'}΋9{9u֪4tk{0WJS	u/:y#+B@!$F76Wu+8gU0LȚ^CGaUY&!MHӤ cJ0nt
yF5zkC긡{9t'ymd_${-g`wFoFXD=<fΧ^qTaX}FRK6s+Am1fhATESG Vh"Kxtp| I(yb{c!r['zu4bJj$+V9>\mg	t|RGA>砬~V*5<+&FPwrJٛٻJ;u>^kN($Z$tD>r1辖H7|-*ꅷ||)6h.2df'ўЏ#,	lhaϞ~߀? @ʰk.|$܎;c%bВ^֋7SÎmK &u#%S+k]Byobc:zFM,[7jQ[]«.Sd\Qlî~&<ED8h'|Ki*2r˙ @9j6`6$zQfC+bk}Ɍỵiw*cY*g`cF$244G>& N(f /Bem9_6ooEgoo2:!rw<#~f8qR[JVo83h[+"芡rZ:(FpJvcUus`(1l?ܢaypUv#aB\=LU\5'L~|Ļ?bJܜq'c䕿bsBizNF/)u	EYg44y2osb[e |)qСǈ¸icp^2ʬ=Lټ`wMd[0c3
y@Ր5o9(>IZ=!.T'琿H2\]fJ^5oV8;'4OB8(0w24U]lU+֛.8Ob^<@`QLٝ Px]m۬H+*7[bds}D3LW}%8=NIoCTQeTtcHXu	@BT (/
	H
M[NR50jKMf rcn0IbOYgxj|7'͌qzI 8;6/4UV"LTȯlM)bMTҨYlJv/yMTLʯieyoY5<07Oaɾ<|+fnݠOo8f	U(+,jqs4臢 $?+dj&{+A
]˥Q:9mLsgho5a%77S1iTLxf@G5L,BP4iz*ɖ,Eі[s)|RQ8$fF YVu(F`)5qMÆ~ 3IpŢHшIK%h܆uGץgfd ߀mΧ	n8>:u3FIHǀ?K>氁P[wDs'uU[<ljɭhYy~c;_14Aj%&`9@:SgN	_U#ìe:g5U}H9o1|lM1D	bO@ڌuT}B20&HK{f|a8G.:.w+-av@CS'~G֠ZI$hL55Oi@ 
JPy{@+agFfP7(SNꆟsl}n[<0#6q}]Zn*@2Dn#TѨv^C;N1V-Sc='Uqs(?=Nw<mն-cb Xl1\-kp[z-HH5e^& 
곱%
]ti=lpH5zjR uCGIؘ @^"x*EcoifФ&E8
1N{ӆ"ktDjnX=-4nگH~OQkoݣuH]#ifh#Q#ߴtïydyiY7J [yo|e!Xj.WW{?=4,J$YGt!QZE_re=#TZY{ bi:h)cX)C8߷I^*=ÍIhk>q>u߬jf~K=iaR!>ņBW>9WlD7ɴrS逊}`DL|0'nllI!8bemftlw_YIJ&޻+5}ތG*R*u=L*ː-ɐT53ngO(GTddn.8=7IO2qhI27LP,Lj7u>oM B*\%\~[p?x=k2n;DUtPJC!8?˯y&R|zd\s](ȴ(h!qAJ1i@x|.[	[yzR9DyPsz:='ж)є%Î)lqekeT"?W8-P0^b.9IK6sZVD5bLf v}>l'糉.Vpz_kmx>TD"˦ID~Nc[rK4A(Te\μ͗(E@8yNB	VugkK|Fwgڦ|q&Pbņg1X3E!vLxF??J,يEzu=BfBpZn&G{,QB{v%+x5Ǣ	N(UD#QҤ8";`(z˓x} J%6ZX&5С~f&	>O݆u ,].ao=y[Ei$0c8@R7]/Unf|dsEr0p=9)NȌ4O<yn6(JiD%@RA	U &	LxEЊz(^Wrjns~	r82 @fld7wl08 5A5+HRON[WN>X={9#]+8B
H]c# #NGR32I
ccCN8u&p [J;,};!lݫlMrE?3aKIfNtQm5y_wSf ۘĠa``˚_}vBlr	BM.c[w-w}I=HFX|/\^G,q0yɗ {>}8h-|L*"Jpp)LOjTox4674P+Nz`y7VCo3AֺL^q;,.o,U3h+QZjwXnK\@[x9Hِb`7H4>`l$7Cg4}[m^'Fʴ¥Kw8lj:u&| c@+kR[7T:<-
>gpES(0-lJN$i	խ^MWNZvc˳Yb5(zHv}F\iŶdh{	k,_e47\S	#}BJ@$r$l
8k!Iʳ9/1Џ4#'˛vv,4R/EVbPHsSACLwAxbQ8Z1ϱ|NdBgvǻ
Cw~	wf,4Sgp9.k=+FXzhqkO/r\<A=q!
EEXI㭧2Ě|Av$0o^LP=C(Ϡ>[_]FXRernDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swal昅xdDH\'KgEdZ
Òv޽xH`$Sɓ|tP>>mZ'*
ԊyFFQA}-n>OvAާ@с[VUq"3}ղ~8ZfK k,la֥U|
J0AN/QG#l}{Lp`|ARf|VADcưlk,'q}S/R{zXm^=OBVgi_QN|StPf@Y:Hbƹ?SKHS{5AncNTb(wfo9>'R_)IPP9T }0l%	x-,+H EvR}=o&(Ok1!0e*8p%%cT{iD6,MHV47o}ѡ#]{/]E]RX?Wl}t{	k)inJUFQسФy-}z,YleW滲Ү i3x]]L)ewn5Kolk ?'U웊;VL/bt/M"ƦJBJHK1
dKm_meכ}4%Qzфh} ,\HBftQhjϠH5MS@9+k@PpQtaI]9qA+,4]oRzk"1?%*yiGzY1DEݜLxLH4*"{hUڭꕻ I2^Z)є]##EhħtmN<8R켦X/E|3oQsR-,d]j=-F[J(pxOmlAe~*">|Ak(}}ţND+EBArZ	p$8Ln"weuC:jvB^kZc>!@ax|R)1o%8۵0.Ͻ[TxFktDrZ@/҅BF)op+ *E Y4y&iyLT2$'O~d3f
RBт/tSXv_IV$)qR5WFp%pirgORG#<\wQ{_KfYn%̞"eO.}4v|!Z:A{Q.u(ݞ>|<UT v{82حJͧO`?3Zkfx6('k/l`ՐObBd;	t-ϾI7,)ДyĎ	h=[.)	.(ǶQSu
0FyEԐNcFo'Iuv2lh%o1cfg>sgL(oaEU6ɗaJ	}]@Abxȵ5-+%Xj	Iϼ
ώҽ^Ȱ!}FGbp\6lwDs&Ԍ4%	0x-,
X<3)la63S8$ewJ5 
bʯ>|6)0`)rSxry](ٓCiqJ\PMVӷ淀2T3zKIF9e] :>'_	km-+WjڌfmwRYxwRh;QVeyXn[#y9K2dyh
U/õVF	ʣ`aFuWO{{}ou*`놚[gz)ޤT	2%)<064
	pVGZNեl8הv1(<o2p< 5dC&Ufm̆?M|@Ftm v#	pV
UaܣG'mweD
7"wvX9oݘڰ`r
uBM0SJ#D0s|k@Rp#)FMÎ@vg/h3`EaE"Z{A܎ϋt[0
Ky7r0v
%V>f	Va2G|Ve&N?A#(*<g];d]-jV?]=~~v'08HZ{D84X:`Zp$UZ&-!_gR쁄ZRلPdMa3FxD%g0(+xHf*S`Nm̢nsA>&}hv͛MbHQ@8lb	<+rWTQkW6`?qQyǈpTU(jm%hg~
$(U/81?x674dih|zEhh1޼um{lm9G@P9 Xݡ~+Nz!8?[)	\6A֤u+a&uCh{<Աn2=H'{3xk]e3pH`j2r{׍vOW5lte;]ѻ,29o?}tC.sh7ƮŏN1_Cn3mf$ RtyA /c-։
UCI$^th=K5veF{@'Clyvq0<,N 4v=-1(@MSTŌ	FWy|s?XPN jF9~	%pZB3C{#;Z*i9C8M#$/P&s9tceɚ-^ΐ&+k-neĔ}6Ԍ<4^@V89~CaF(2.4hyےMﺴȞ@ҢQSYWpU{-|8)\ȼ0B?<qx`hI+-hzE1?wT4@4sw{xȦdAe{ArM⯩3>Cb H
$)Xx\ZStw!|GyXuP(=fT57gq%G(& 8PuSKgsH6=S;wB5(O_Фf-7N)ta>oZԔg5zTI,L*Pc$L@@j`1'ZdQ,&)[	Ep8n\ZkyWs@]b@Sn8h7J,הTgX9=ߪAD~:[]SL@	~1l}AwKOYcPeZj$B؝sV_J{KHקp0xr+Z{wC͙ړ5Rl3Ϊ~,Ooo/^Cr$:T4-8郮QrNUVӆ&^r]pmj	Z+IH.x;6Ѹ!XJyZِfB*x<'L H6j܂*i*t>݋uh5iS?OFt^,a&A=^yF3JUm}63u8`b $4͇ A]+1$Di'PgdXDקRiknX p$IRR:HV'2`kGwQ38R{hxlIYI[ځDXPy'Hm/ݡ) ^aYؽܦ;iʈZGFϋCᐺBpHz.В;ȌBM殔KeExm*\%@i%Z{dfze|ϼ`1oYQv3,r0bk<xa<(q0oRB'Ic>_8.s/uT5/F3.GrA
W]53#W8XqSCEtyZ2W5C\ɃJq뮣Eid"qjwZފ$?hmNWK
^pN2V >kЉ5Iz?aa4 VԀY	|=Y4cгVn[RI=9cız5z#t
Q1cZ#ao縋HZ]OaN.u>}7%@{?aE/#6	P;lN^mMԨ )!5VaZqP)bv%X)9	ӛ=eLڕ
Ee^rþ1S 
j1Lu)8 I0LiTIyAoX{'nJw?	s	Ű)KDF,x?(B90P@1gX@8BV#Df.
Z!4=O~dD7(DyUaSgnUJVfj-KƊEY	,nv
vЉ'$R0	!u;%4u'6񟢩s]9,E()T YAHGcajNܛP'}rH5J݉@1fg	̒MFlzQtR)rܶ篠*RxvߛWvka^+X wv&ꪩ/Vd dEL%^srgL{`YsuK鲿zAt&pt.y+&MkzƋ=167U7#wK;ˎS3|S4#$nbp[M+Ϛğ-ų%["y\t9ΐm1+`sKsi(r[xr'b<v+gC
H!#13mY`wMǃ0ΡH־ V{M=pPG`[Yx}lQw~KVlFgo=9*
jTwЯ8YXW6F?$LJ;+cP&ruϞO4)vrrrF#.8X0:CuxItf -KCmF~+ݱC,g]342Eu8C*'?nO&kq¬M:z4lŢzjfuiThr;
-\ ֌Ia}']Ҡ[,ޣ;[Ul.sZ*!&uRsߟ j<^+O74esϥ&uU
X2"ةZ 0&mQ	z]\=۽
&BC2ئ\$gÑ9燃h86!z@1dGG5j[&ӵq(L/ &lDϚD\3myIY>2$<hFd:[ЅϑdNP>BUؾ('U70bgQnbpt%:nc$NPObtHZLdxO,pAGRH,MIU{v"z^sY	>%Ϩ0CL\,C1&>ZV?ozI<$\L ˑc[)":q%N,WE}B(xAElTF5DrSρ#7倇e݌Zlecru>9p*RYz4p8QSzgp#ǵ'_Sށw@3U\X'mPC6Io`YpL)aP35GS_rWM"esF֣	m	ZgABY"-Cr204ae(Lv 2J8IA.W6[ԥ!@T,yO\[2U*ݪyo@[
x1RdGd4r!K2Vm2b/!"
8R: 8R`"K"n!M?(ǍJb5	F\9Q0у^0yPsA&!u!C.BX-6*g`Y
ƒ*!	ob!pFMn<xS	U$Y~㧣L*,GÚ`.
B3,4:Z74$>}(8\[r-sAvI̢h$;[84
GA>vܓC_G3*NCѧyH:"TZdIc'͇$)}/'$=|P{۝#8-Kkuć	ב֐=CiMOcxgkZHy܂	m,zm:;C3+̓Mq/+Xƥh1m/a}ۏSg<¯(x?lH?p
f7#w2t6A!v+df/v51d22h>yn?[A;hnyL&9z}P3A<֎!q:1kD:A恙Q0,Zb-적)w͙V%Iw 酺17Cxu%Wc)EZ2ao+!V:!荋
;dOTmrhӑ.?|?xq2!Qx̺j/b5<J`͌~	a#$ KS/>e0^1	k݌ƨ$LɝۙGPuT{sfi47ǣGǰR̽AswF{e"pͰI.@\\\X̿e=NNx~ 6nYTS!YELِ;gOY5>7a,̋[Ǘ3-0?(Κ`xiYHL<poDF[gw>@pC>m|EU\c|f$)5YКL&B{碟KkCN4N:{k.f`o@$"/&fn3+*^%\hA*,P<>/L-JYT*>Azr1(m"z|QQ0Jx4\y OX=Ku.2>ȇWB_h轴<6"`'n>YTwU63)qKԓJZ%Y4VaB.:^@ '̦h|5蠇8!xomQMhƚS	YŻaq!@UI["D\Z8XKAAR\5spn8y̒v\,lFѭѝCт{wkJڹdia7\o
kA9c3en]dCD.]5y"	݀ "WYqL"Ѥ21BSGGڑtmϣT"{{?oYzWG,Y7t7S@-Q>op].n?rI)Ə)_{(-`+RtvL'2Fp
.Arah1T7lٮ(jpP=UÂp$yӒy`}ztЇ(qKk`yr.eQ1^8DBbxadvˠƐZP4"|oAT%قpa`>ǌpĤ(ZN0w=+b!oK
`T͡DF*hUP ctc>5e}Zyb@SÑPSM eO=' /hپ>ȿd3 #hfE*'zяko.vCK8)\7y639\#p%.}&ͤ5X ^}NӁ4rtpX؈b}*sӟ	RbQS=Bv_4lt1Jz`pNSUh!A_n^X'4J޲ThEzh!	!czvz%(]B[%sa]6lh}e:!ugɧDuP߻Έ,de7GvGNB5aO=cpJY7gE%)z7Q_/uZQĬgeggajﶎqhyM>S-Z7UqvM޾>}ٙ0 $KBylF+낭/ѫmMwKj&5L_ H1Pַ̠DVl<61Js݊DGЈ˨0k߾9-D6 X2$s#͝ -SDP)y.hذfamC1oNj uh) % LyvrtT?"a<Q YKU^H,%!IoF1G˖L4a	I0
FxxSt4v-J-{jSz%)ʹ7Z[ +*1`76,jqotQ%`c|ȏs.ÔO=y$cJaYѡղrRC-JN#`epH`4A(xb7Vs4a wX&寷ώfj%`G+{_C3a7O@ǚQ. !d`?Z	֓ߥ[Xt'jG=Z,1)Wv7EkQ;(KH^%>8;fZ^*aOK"uڙ=9quN+C% ZӚZci(\  "=MHKKqRu`fϱh!I$-^>F:E8XO*JZޱ&09)2}C̎{1^T't޶bjHҩcj{+J^Jt·ܝp$>CZ$:<eYEJ	H3ۜ~VUd'|ɪO`'߫;DEfž(,XuψL!kRԝ';m^YsQ0haqUy, ;Sj1yV񩧤tP^U,jY)A!kǦqB
Vܤ	xXŢc^iSmSl~o#LksFuq.)Tc%'Xmw6.tW[!7F'nBM}w,hj'X-~F^m,>&
R Mtvt$I5װ\r__J=a\EOIZ8W#f
	c N0c[x.orVN0e9멖JyR?t8
"ӲyѦAȎt,	؏fF;3A!o,jXXPtEvF$ihB>iĞ43W at^h]w>Bfԑn'AI},,DtEfQңáD>~F@hCæAe5%5g}Å#0ukpE!eP+_&yB2r~Q
FOZP걎(EDK(4HQ{
%6Nu'oPo&PַmH
ac
^a7vA	`;ZdafTgbg>4$,XQWr,65&&f޵l4>nӓ䜼&걵oiQ2uIX\̙[?DK?1:-<^EOAXE"2FGQmW!w#.hb$xn,2QDc
zϖ4=@Rֻ<ROWˉ'Xo+K`-IΜ^_jj$Scs4Cy	}<l=d"vqC '۔mj/f-yL{ogNkc!ƫ˚וe~rT̽o֗aཫuv-J*S9s8s%-Yׯ<Q*ϻ6;o<fǴJQ)ᑉ>f/d5JW%WZ| (JhE{Iwጚ(\({Ѷx󶆳?Q}<W"e4gŇ8ް{BԑgePi {H"k{#M==5^)̴*lkt4{'{kPsiRWH{?7Hhr ]V`_}<^,h`ßZNMʽEYe2"pۜwbHX$ȧlJM$c"yX6*o&WrIaU=ـFtUuSCM?Y!5;u?W+޺_+i~ۨq]m6
g"N K\SUxxDɟM_II7'*wQ$"ZXBU$|,ڦ{jH}p0	i$mkŝeJڔVW3/ߨrkw"ΩgE$Qdh4U;}ŏl}	UڰAzҹr]ŃQRI]u5 W0r4fd"@4_1AҕBPi)gjڢt~Ku?\}}quI
C&drO=~Ӌ30^*eudo@FPPQ#~,4SD;Ѝ='2}=OV򹹻 z%z7g>{r1(z+桄yx,8Oq#a.1F}HIRLZN٦%'dk	";uep"-5MՀzX2PX.RYSq<LF 7?[nJP5\&FK0[=<0uuY#TYm	$I:K\8*5->jhYd!>cTDXvTC?Mq]3d-̜heaٷ*4W)U9! >a	Is[OH7 +<(82DM@l7Zpy{4
3RAkƌwcy8 B/R"!ѭ>)znh'2,jGk2EP6A/&\QH+@:IUj}5{vCJ-0'؝GL>:z (Z
7p
Y2ygy,}$`%{gy;HsM{F|OAHA`rfeo0O3/h"Lآè"M7CX]Q!g՗%d!K,{}5EvbuWlZ\we9n~Cd}1xG