/* eslint max-len: 0 */

import {
  eat,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  popTypeContext,
  pushTypeContext,

} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {input, state} from "../traverser/base";
import {
  baseParseMaybeAssign,
  baseParseSubscript,
  baseParseSubscripts,
  parseArrow,
  parseArrowExpression,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,

} from "../traverser/expression";
import {
  baseParseExportStar,
  parseExport,
  parseExportFrom,
  parseExportSpecifiers,
  parseFunctionParams,
  parseImport,
  parseStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  isContextual,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || tt.colon);
  flowParseType();
  popTypeContext(oldIsType);
}

function flowParsePredicate() {
  expect(tt.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  if (match(tt.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(tt.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}

function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  next();
  parseIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  flowParseFunctionTypeParams();
  expect(tt.parenR);

  flowParseTypeAndPredicateInitialiser();

  semicolon();
}

function flowParseDeclare() {
  if (match(tt._class)) {
    flowParseDeclareClass();
  } else if (match(tt._function)) {
    flowParseDeclareFunction();
  } else if (match(tt._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(tt.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(tt._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}

function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}

function flowParseDeclareModule() {
  if (match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }

  expect(tt.braceL);
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(tt.braceR);
}

function flowParseDeclareExportDeclaration() {
  expect(tt._export);

  if (eat(tt._default)) {
    if (match(tt._function) || match(tt._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      semicolon();
    }
  } else if (
    match(tt._var) || // declare export var ...
    match(tt._function) || // declare export function ...
    match(tt._class) || // declare export class ...
    isContextual(ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    match(tt.star) || // declare export * from ''
    match(tt.braceL) || // declare export {} ...
    isContextual(ContextualKeyword._interface) || // declare export interface ...
    isContextual(ContextualKeyword._type) || // declare export type ...
    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    parseExport();
  } else {
    unexpected();
  }
}

function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}

function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  parseIdentifier();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(tt.eq);
  semicolon();
}

function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (match(tt.colon)) {
    flowParseTypeInitialiser(tt.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(tt.eq);
  }
  semicolon();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (eat(tt.eq)) {
    flowParseType();
  }
}

export function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (match(tt.lessThan) || match(tt.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }

  do {
    flowParseTypeParameter();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  } while (!match(tt.greaterThan) && !state.error);
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.lessThan);
  while (!match(tt.greaterThan) && !state.error) {
    flowParseType();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  }
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (match(tt.num) || match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (lookaheadType() === tt.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(tt.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  expect(tt.bracketR);
  expect(tt.bracketR);
  if (match(tt.lessThan) || match(tt.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(tt.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }

  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(tt.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match(tt.braceBarL)) {
    expect(tt.braceBarL);
    endDelim = tt.braceBarR;
  } else {
    expect(tt.braceL);
    endDelim = tt.braceR;
  }

  while (!match(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
      }
    }

    flowParseVariance();

    if (eat(tt.bracketL)) {
      if (eat(tt.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match(tt.parenL) || match(tt.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {
          next();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  expect(endDelim);
}

function flowParseObjectTypeProperty() {
  if (match(tt.ellipsis)) {
    expect(tt.ellipsis);
    if (!eat(tt.comma)) {
      eat(tt.semi);
    }
    // Explicit inexact object syntax.
    if (match(tt.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match(tt.lessThan) || match(tt.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      eat(tt.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {
    unexpected();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(tt.dot)) {
    parseIdentifier();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  expect(tt._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  expect(tt.bracketL);
  // We allow trailing commas
  while (state.pos < input.length && !match(tt.bracketR)) {
    flowParseType();
    if (match(tt.bracketR)) {
      break;
    }
    expect(tt.comma);
  }
  expect(tt.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === tt.colon || lookahead === tt.question) {
    parseIdentifier();
    eat(tt.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }
  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;

  switch (state.type) {
    case tt.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }

    case tt.braceL:
      flowParseObjectType(false, false, false);
      return;

    case tt.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case tt.bracketL:
      flowParseTupleType();
      return;

    case tt.lessThan:
      flowParseTypeParameterDeclaration();
      expect(tt.parenL);
      flowParseFunctionTypeParams();
      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.parenL:
      next();

      // Check to see if this is actually a grouped type
      if (!match(tt.parenR) && !match(tt.ellipsis)) {
        if (match(tt.name)) {
          const token = lookaheadType();
          isGroupedType = token !== tt.question && token !== tt.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          state.noAnonFunctionType ||
          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))
        ) {
          expect(tt.parenR);
          return;
        } else {
          // Eat a comma if there is one
          eat(tt.comma);
        }
      }

      flowParseFunctionTypeParams();

      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.minus:
      next();
      parseLiteral();
      return;

    case tt.string:
    case tt.num:
    case tt._true:
    case tt._false:
    case tt._null:
    case tt._this:
    case tt._void:
    case tt.star:
      next();
      return;

    default:
      if (state.type === tt._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
  }

  unexpected();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {
    eat(tt.questionDot);
    expect(tt.bracketL);
    if (eat(tt.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      expect(tt.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (eat(tt.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(tt.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  eat(tt.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(tt.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  eat(tt.bitwiseOR);
  flowParseIntersectionType();
  while (eat(tt.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

export function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

export function flowParseVariance() {
  if (match(tt.plus) || match(tt.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}

// ==================================
// Overrides
// ==================================

export function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (match(tt.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  parseFunctionBody(false, funcContextId);
}

export function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    next();
    flowParseTypeParameterInstantiation();
    expect(tt.parenL);
    parseCallExpressionArguments();
    return;
  } else if (!noCalls && match(tt.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    expect(tt.parenL);
    parseCallExpressionArguments();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}

export function flowStartParseNewArguments() {
  if (match(tt.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}

// interfaces
export function flowTryParseStatement() {
  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {
    const oldIsType = pushTypeContext(0);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
    return true;
  } else if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}

export function flowTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}

// declares, interfaces and type aliases
export function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === ContextualKeyword._declare) {
    if (
      match(tt._class) ||
      match(tt.name) ||
      match(tt._function) ||
      match(tt._var) ||
      match(tt._export)
    ) {
      const oldIsType = pushTypeContext(1);
      flowParseDeclare();
      popTypeContext(oldIsType);
    }
  } else if (match(tt.name)) {
    if (contextualKeyword === ContextualKeyword._interface) {
      const oldIsType = pushTypeContext(1);
      flowParseInterface();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._type) {
      const oldIsType = pushTypeContext(1);
      flowParseTypeAlias();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._opaque) {
      const oldIsType = pushTypeContext(1);
      flowParseOpaqueType(false);
      popTypeContext(oldIsType);
    }
  }
  semicolon();
}

// export type
export function flowShouldParseExportDeclaration() {
  return (
    isContextual(ContextualKeyword._type) ||
    isContextual(ContextualKeyword._interface) ||
    isContextual(ContextualKeyword._opaque) ||
    isContextual(ContextualKeyword._enum)
  );
}

export function flowShouldDisallowExportDefaultSpecifier() {
  return (
    match(tt.name) &&
    (state.contextualKeyword === ContextualKeyword._type ||
      state.contextualKeyword === ContextualKeyword._interface ||
      state.contextualKeyword === ContextualKeyword._opaque ||
      state.contextualKeyword === ContextualKeyword._enum)
  );
}

export function flowParseExportDeclaration() {
  if (isContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(1);
    next();

    if (match(tt.braceL)) {
      // export type { foo, bar };
      parseExportSpecifiers();
      parseExportFrom();
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._opaque)) {
    const oldIsType = pushTypeContext(1);
    next();
    // export opaque type Foo = Bar;
    flowParseOpaqueType(false);
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
  } else {
    parseStatement(true);
  }
}

export function flowShouldParseExportStar() {
  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);
}

export function flowParseExportStar() {
  if (eatContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(2);
    baseParseExportStar();
    popTypeContext(oldIsType);
  } else {
    bas Ôî-GÃI<­ä‰kĞui-z>—¹œ–=r“ãsÚƒ’ê÷óÎI°à‹¬!å£TqìxS%xZ!Ø¢€+ç¢s9.¡s¢“Âü“7•&Ul ÿ‘f%Eê(oY«UÇE’)ÒG=‚Æ!rtÔM,º?¢ğ» _3¿y
¬p èÓ§wF­ÿİ@'…÷ê¥G?ÿù€ş/€Ä¸Òİ‰„Ö¦æcµX|GÄĞœ9lâğ¢:Ó;£:+T0mğŸ"±Ø…i˜‚¥º9‹{öÅ¬”)e5$/-ßà@?Ôé*?-±W†É„°7'<ë"è6Ü~Š3Qvcˆ(ïæ4ä,pmƒ¬9Çlô•–€/è97úÇ«²F#ü„Ù¢Ô Wàƒá<ÖÎ%TO_ñÏÇ±¡ştä™7uäu;úƒtÛ?¶Õ•y;.¾”¿<1¯+‘2Ò®V’Æ¬\Ïv8LØÖŸBcLÔŞŒ*¹XÔyìÜâ—ÊˆÈëBS7e™Y;*…ëô”
lM©Îk§"HP(l©×zR¡{îO]òc6B‰RUTÂùúÏì‹x0cQŸÒëpcIÖ+¬úü×Í»õOáî¢cÕbd±¶ñš¿Mgå
¥lcÚ6lfHåÃFÊiµ…Š‚¦×‡B/îh•–Á¨éà,¹÷ &KC‘DDtfˆ>¿áÖÂ^±Ğ5…½”Ew@ÇŒ–oe•gİGÃ‘‰•¶ãIKº‡xİCME{ßvä ’‚IW‹Iµt¬»0C[ÖÊ° ´9kŞqÙãÁÓîª~gww®Ø¾Æ“‘øiÓj¯¢Ç¨Ç+®-Û¸İœf¬ONÏgÊ¼­Ş ƒ]‚lD é“A,<§ø÷şY4w‹U×vHEËêbë÷ë³+.Ô¦Œ˜x.~Pe„9®}$å-F^Ñ?¹y	ê~ÁoF´Ù|JxsÃ²ñ†ıG7,SŒIå	%÷6bŞÂIÃ>'Q¾>»$jF‡Iâ¼7Á…Úòa²ï”¦Nvn;4àÆíë$x/!7§õQìC•äÚÉÒæ^Ëz†Œ>O$…mç‘dÒ¢¹é¼'l=¸<Ecš£¸îa²&$­’@}œñ¾FîoO‚Ëià˜ûpnqrvdJv°Õwöÿ¬$ù'‰™½=ñP"²ü!ş8.kUš>äÂ­ç9b„Ì]h2pÛ3ëUç¹‘j,:IúúÓ]Øá¡”µCl£´çÏ)u—¶·§!ÒÂîî‚L¬Hú%½×äS"¬¸›y.‚±ôë°y+‰Ó$Ó„âÌû÷|~DÂÇ<»¥¬ÏÁ´×Ê0ÇøeyKAŞf^K«q&*‹XµŸ¡ÍÔ­bTdÃQ
èO¬•^kÓµÕ\º1Äa[	?]ë4tV‚kP™õ ?/)vH ¶8?'øeG½mL(ÕÕŸÂvõ>.dŸ…«m[İ?¶ÈÅÁ–ŒşŠ:ªjç´w¥¶ƒ‡'àDÈ{ÖÆ~¯Sßuşã³MA“Cc–ŠÑT“«""›åw¶`Ù|4z{H6ÓEè°sO"98ìµvÇ¿IQˆ{RG
İgüÒ½+¸™œ)¼?t=JÇuLÌ}}ŞFïyÉ°Í‹†ï¨k­^ûV%ûLzJ÷7x,Ç‰¯äiğ«mİ¬ø×´¤Õ.àIB’)ŞÛ~¿ôšs%çG!4‘‡_1š=7…÷JaÄR².ß\N3É2c»4rOª\ó’õ¢‘Ã…P9B–Tà'há+ÙWîğÔ‡èÊÏEÛW
ÍÖŸ¬ô08×ıQÌIaë–?Š}ÿ€>„Và¥@lƒğ6Î<{¼†£¶ZêÍ¿]ÏŒ' øÄ&ìÈÙÄ@ê“&ªÁüğPm÷HMú?bwm"é9¶¡?k’e®èÀ8åpŸ.0ÍMÀr)»¯ÎÈuøJ´ñö•»Y·ÑóìÍ)eÅËóiFŞYWöZ|J^ókñœ¾äO¶ÿ¾6İÏ'Ÿ7áÈw^:¯õY*"¸,pÓt-?‹Ì:ß•ÛIïk?Ûo×ÿçõ’°¶+·¿·¯å5³}dTW–êÀñdÖ&¯Ú¬|nç×éú%}Kş°÷Àúû1ù?”ôC«'ÚQ9V[Ó:ÿ‰æ[ªÁæ‘bñËå7¨d•ízßâYkĞjû'ı‹©:±¥,ı…/=».éşÂÌ½ĞoÃï7'8é¥`ò‚(CxâL}é=öÆ*fÿÂ¥<ïwmõ2©«6{UåZ©¶ÂnÖˆĞH!°67Ù0VÓ†æé®æØ	ïp‘ÿş4›²9<g>ùk3E÷î7BiúPV‰:V[¤l×‹†ÂµÂWÔÿº¶7eAZ¦_Ú¾®¦ŸEÿÕ‚ÂsußbüNÏ>?ëÎèWr¯‰‡[	B’ÉÏúë“Ø½®K=g™08Ï{ï‡O“z²×k½j/»Û–O—³ïÖ¦)™:âWğx3Ã7‡çëæßşÌ;¸ÁfêÃ{?ØÇÂóÙiùÙ« åIüÁgùnä,_“ûÏ+:láÌP£«SÜ2mà¾X™‹}¬\ä°=v2ûB’LDCĞÙpØT¢#jyÌv†Z4]?kƒTX)Ã%B møáí„ËµCÔ¦LXi°ÂÒmëEt­×·š9“¤=Jwõ«'ÏR
x<|HCŠÙ:—±vµkjAö×Mbá´›Q}â2WéÉyÀpŒb7>!ï1ÆŸßŸW$04Xª¯·"Ÿ3>O7IÓï´5ız›QõoÌyñóËöËëx…Ì«Ä¡¯j›Äª¦1Ï¦#ı;Ølæ¢ÎñÀm˜Şó†^(¯j7;HEP±Àgˆ?¿:¬6vmı¼zİ°Â·^Ç¡î‘ŸÄ“ ©×ş»Ò©Œø²Q¯ÆËa™Lñÿ—iÃ4ÈúÃ(eßQü%µf¯ê@Á{ŞŸuÛ	!{éx×*Y&¤­ç|mË±Ró3­5Wívµâ·úï@EÆWƒüÿm¼ªÊ¶gYk·Ó…˜\ŸúiİWq§¸:pGµè‡Î/Ì]~Ç;ğ)ûh–^R–~ï5'AFtÊÃ§Š«EexNã:îe±8Bé+§°›y×w­FéÆîùJÆ>öËÄÿÉ
1J„êS‚eªlMpKlµúcU]Cø©lÆ½HâWiÈÏ
İºÊÍ÷Q1ªñ‹»ˆ…EïpËwvÁØ[Y}R%#Ã‚kß[úmCğ-êÇcÚàßºõw—“ñÛô€p¹ôï§Wúw!1?¶,şğ?Õ„Ã‹}ØbÒSÎüã·àğ?KÎß¶*#ŒœŒäĞÿhÈ+ÜR°lØ‡Z¸MÃäÙèäA9ŞåWl!f€ñJPòÌ):›4î3~0äTì4BàÏÒCó<È¦~øÀdOÀO
zŒœoR!şŠHù³]ïƒ©W›Ÿ½?cÂ*2c,0Õjuè1k,,`[ó’+	Š±áäkÏ¯G½¸í©Ñé[NÏ1ï–q%-¢(šV\Cséé¶Æ£m­¤^?ŞZ³F½¿k6ø›Â¢Z¯é„ÿo^3yÑ}¬g[Ü,?AN|d¥×Üu§oH@ïåŸ‘ÒÃ½s»/Dœ^ªì-Õ\_*èQU;'X.¦ïÿ\=ƒ¥jÎ¥6CÄÖ¤f¢ûŸÃ†0í¸51`a=–ˆuÈÎçÖ¬rØ¯I2€r«U»U)­=GÊ'ÀÛü×[’œ¥ä«ê-ßæºÚáÂñÖhÁı{aÓ7éÄ4©jXòÓnœÇ>±]…ÌFúQX“âç¥ğGRÅıÓ/l¸Åb‡]¼oI*êMæ"-I‘£L^|6À²îÖÎP;:©ê.p#Ğ<g;£øõw¤rb2lÙ¹½¡CtXù…_„vI%K»Ázõ5MÂH¶äê|Ê©ŞñÜ›¼ñï0ÙEcà\ÿ“jMŠjË ³•BÑö0††@ëôÒË·÷ÌFÚ»Œ·ä"„q(õ\ËÊ¸jI)JlşÁÈ¶Õì+Jš€4vKMÎşGKâ‚ıl6$]ëè*d8Bëj'AiNXµ9ÖÑà”ì®“İë°óİåTEËê9sùÂQŞë_;Kù_”ş)ä"úï?*õu_Â‚¹:d<u;D‡9œñË»2î|QÁ,^·31Ç2)´~s\Ë@GBç™÷EôO
"ş"s;Zyì „[Ìş&âƒ³ÃKpbÛ¦£ÁÜq¾]jiğœ·•x]é\^Ñ©~$Üòì¥6Bğ||«¦P{İ•ô"¨4toã|Y[¡¶Odº<nIã“'£·ñP’«8EÔĞì›´Æ-¿İ.üÑ“ƒµCĞ¥•Ñ(Œp…ğ-¯'(ğ/uáX™+ĞT\ˆø¸–¬JY©¡ˆ™‚'8í.zÚòu‚àÆEï“h.Œèrá0[ãM±¨ÙCs1ºš÷Ä½Îp›8&
:›‚¼k”%g$há6XÂİÑE^èD¿Tš=Bğnş °ˆ¼ü#vv €vräşÿàÌvIÿ ‰¨ü©F>ÉmüME´ÃxéÕöªÖõ«MdŸÙÆä]XïHMúûófµ5MaY9Û5N^yr[ˆù¯ş”Ô”-¸0–5-§Ìh„3¿Eó=îÔ¢Jmy¡¬eã·2öäbvÑòê&6Ÿ5÷ÿø–rhl™y1½|‚MGı§O=7î¢ÖaíU‰j-ïısÍXçºT½É’9+$wñ‘*“9Ê2ÒâP-µÚ6WáOÅ×³Æd\­…ê60\S7Â;BM¬´ÑßU(™åÉ#î è`Z~íBœ<Ñÿ¨úº#†Ş²V×ù§•;‚®=b±­®øÿMÀÖÖÍÇ¿4–3j"î˜¥,â×ÚIa?Âaı†ÒªuS+ÎŸ-ÚûÉÖ¡¿ô{¯zñGÅeü*Uöo
\W S+eûVÂ°ë2¯˜HP’25=1z×²Ã]ğã¶ŒXÀËaá1—œè|üŞ«Ú l¨±·m¢Q«ÚÆMÎâ}VÛñ}ŞKf“ö2¶Ô¶ µáo_oM¿“ŞÇzêÈ²¯€ïÉ Ùï°ìª¡¹ddß¦™x/ó8Ràï·Èõàã¦©@~ã{iˆâ):]ÀN•ID'äL(³EÇşO,ŸA+oİmŸkå¾¼];3x°Á.Ü]¥ëê'ms§(“î-$4ÔšhFÔ¶aK6A’}F>¿Ê¹o úÔ5»ù@z•+45_I½—fÀ¿#h|S‚xáhEWxJ‹ştÆr/Ÿ¡ ’£ŞÖ¿lº3d±XRfĞìÇãÅÖåÀ½÷ŞèHc×%ùi9È¸ªQ£ƒBDØ$ôm‚÷X|tß¨ŞFœü¹\İ¿ù#¼Á }¹Ÿ?Cé»~Ùæoâ°ó@j1+#ü¹àĞ§ogò>û.MäYÍ(D!Õ
¼òÏ1­ÃÀi^›ºğçWZ"y,â±î¿c8ÿ¾GêGNÏEÄPòŸ±WvŸï½Ñ=„0U&*U?ÿá¨ı¸á™Œ›I±Y$MTÂª_òåøµşøÌ”™[ÑöIÆØôMºÏ™<Ş)ÈE"ÒZê=@NU®Êb¬ÕñÂÜÍhÚe5&{¹‹²Øò0(ƒïòÅÙ}—~zãu¡úXQJıRfÖF²—èfõNlO­)k–Bøx§<;q—¨^ ½‘-à©‡K}d]yµ¼%ô…ZwCÃãIœĞ°Í¶à?<Ë$#H¡¾ì¨}-‹¾á¾XC5÷wÀş3¶F—ğ¦Wİ†6ôÎeéd1x€ƒgÙ¡ıüÔ«vˆ¥éN~6˜0ú×gÊ0ÊŒ:W­Nµ¹BÎıaäcÙ±TÏOÑ
ÁÓàÉ’rôt¼ÜÚ¨¤—«9°«Jç§¿va’‰…1È?E:2Œr|zpe†NßV]kràƒ”À˜Mõ»§«]òe3¹(d+bÈ¶z)Æ‰¯Š‡åDôÑ¶ÙA´0(kXËˆqå^@s¸ä”EÆÁA ÉìöUèÌø¼¾,\[[] ÜÁ^ˆá»>¹Q¹ØNğí)}ƒî|Ó'w»şä‚ ’ˆöÁg»Ñ¨P¼eö)œT$ÉZ%ÑçSÄ±Ï¯ÚJiõË\‘2ÀMW‡ã©©F‘ÒİïóƒÈ`ÂìÕyX„O½2²sÒUûÉ€¤ìØg3¤ù.bS æ­´²;¶¶,Ñû¦ÊÜ¥¦j„Ór³†`"/mˆ@!ÇÃ)5TÔœ!°šÖ/ÇDÌá¯…ÿ)é³ÕÀ—6 • [¦]:Õ§½”…ës¿j;Ñmš3ò4wÀ°UÂ|cR¿]QÔ©¬ËE–u5»NÓxjí–öz`¨e.Ua7åí]÷Ù÷€P¼¯\£—	 ŞØ¢ƒÕ.ãÆ¾a®r2ÄpJ­„6Ë<Y—$v;1M©°ÿ0r®”[c´lgW÷VÊSè:¹…;
p{½œâÿ\Çw§}ÍÀé´ØÇøl÷m…‡‘OÏŸo;¥d–P™Ràsƒ~–€OË¯/Ÿ´•ß½’Å”ZŒ„R¨Iƒ‹!K’’Šùö'7£I(2ÏBDñ*z|ºV+Ç½}#[–ÈàßİÑïEğDV±´1‘Nƒ°rv¿Òj÷â¾ fëQf¸Q“Ek%bÏ,ºRC’­
ÌÎR.[™}uË‚dˆšiã€¤ºÆuËeÇ„E”=ãÃÏ, u†4ç%’“=F™E²VIC“T—ş#Ç@’ş›?T-CŠ”0ñ7sfÛqüãAœ¸3jG»*¬Zµ¾´Æ…Ò4NSû¾A60ŞÒŸ‰ìağ^ã–¸rÛùè™ÍÖXŞorûÇîdt·*ªŠúr[ÛÍŒÑg´L±~ÄûY	ªxC3²¯)4è[ƒx.ÜÆƒ¨VÌ÷	K¨9F¿ÎO âêË†ˆÃ¾jeÿFS0g_`¯îÛ¨Ë|Í«~n£:ãO‡ˆYÃ^‰°ÕÌ9ı‘ÆD©†gAhüÿhn‘<vzî|§œ
xŠºzv‚á_9‘âmÑÀ¯­AÎˆÛÛÆp»Ò3©†?&ÃøÿÎ—Îª„§9ÏgøIyÓk ’Ÿ»öm‚*V;êÍ+®hÅå%¾yaş¶8ØÙrœÌYÔÎÎ7cs0ÿÒOn™)Púø>F:u’Ø‡#õ˜y{cŞHø@%}0¢R(RéBuˆu’pg£(×Có27M‡HÅšî-9*jgßÑÆŸÚµÎr½)Ø"‘%ÃëÒ\{ÑjQ0
6JÌgpyÏ>!ÈA<³òGYğ‹Dş†Äs!ª:ìr¶¶ÎE°bà•SeÓ´ê¹†%ĞÍ0.…’>ìÈ©I×Ykf)=¥ÄHşÏ(˜¸ó‹“k+ÖìjbÜÈ.€.É¨µ5…<Ş÷@Ê¾¨€hœ÷ãSË®NRÙ|Oa›—2“H#nhÒ58¨›p]7vÜúÕıƒ–’8G
íz¥×}Rj“‹ªµ“dyüUšíò3¢ê£%gôem¥çCÎ[˜ÿáL²D)%6
óıøå§n”F¨c<¸q%ıI•è]²ÕÔk¥¿&IlœØXİšo$½=›ŞQœÒ=a:-zn£Ú‰Ã[4L‹~¡šzùãjTÅ˜ M¾µ¢>Z#PòÊ‰
:£XOPVö†‚üìx’ÕàÇ èÌuë¸ùªÊ]»Ü‡cXª.2¥‹1W#À#zÖ‰æp‘òA´d©/ĞÓ ù…waöã
Œ´xòW/'h~*h@Á*;şµYÍ‹Ú\Ê?ÕZtôô‘?ö'¼jâØ;ş¤¹#]sîNÛÈv!#¾½¾l+:†%˜ÇDèvKô^JäÁa )
1¯ú6=x¢NÕ¡ÄO°h÷4cÉ³?ô–ào]Xbõæ+„ˆïT·†§àˆ;³\\L~»o,Ü»ìİşŞ"t½Ônºì“‰Äq(’™¨çu/³ù§˜œ=gÁO5¤ééd{%Z­¶­cñ÷·ÜIòX„HOÔÌ•lìK¡“y5¼¥÷š~š ¼Y«Bá0ü¦v4¯ÿ9Ïß|¡&„”H“ên†
ïV–™tTš¤ò 3èö»à`Á,ìˆÓXĞÏ´Û4dÇÕşQêıÔ(Álÿ2ƒ‚Iøj§8Ê¾¶ş›ïùstÔ¿‚­óõ æTŠlµL#„(ôlÙÓ<ÍÜI	':‡íì|:Ø{ñ±!³“Í3