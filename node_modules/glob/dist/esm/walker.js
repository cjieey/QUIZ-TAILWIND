/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
import { Minipass } from 'minipass';
import { Ignore } from './ignore.js';
import { Processor } from './processor.js';
const makeIgnore = (ignore, opts) => typeof ignore === 'string'
    ? new Ignore([ignore], opts)
    : Array.isArray(ignore)
        ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
export class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)
            ? e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)
                ? '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
           ‹ÿ­aGú;™­Ìı˜”åá:B=Ê“ÓÀzû†=¢¿¦Ø¸¶búçìÛi]m´<nµUZµ3Ï‹PvR±ÚÓöš>`qpígöS>ø+%†Â,'T¶`ƒãÁjmÌM\ò(c½§‚"@íš\Ç&{á{=‹yÒ„ ®xCÒ·š£ß‡ïšW½W€’zx©& ÑñŠ£ìşs_‡v[¡hiwÈs8éäeIşû³á“x Èy5íİéS·ó—á6™KO„ïsÉ sıêˆ)6•Ä&ËPW—úKÃ×M¸›C`[Wô>–ËÔ·§ÜËü¬ÿß)—æ½ş·{£ÿúÕ’—òÜÏKj'ô>Ôûc÷ôÍhÜczV®$2
v­Û¥º¨oéé¥ıáŒñÎZH>õP<.³]|b àÙf’äÑnv3ŠÁ‹”÷Ï¹_r_0‘ õy«íæïVPıà–¦¯$(vTİ¬æª Pq²vÎ0ÓS6{	ëÎ÷­¥°ê:&#ß\Ÿ¥¡3Aìf¯¥¡w%Ôƒé„eûc'Æ{Lx_ÿp°U
hUFt^ëÊ‚¹O…éÏİudÅgŠJŸRŒ=uâƒÁª3÷Æà¢×Gy`ñ¨OÀß/X'õûq0¶×(	i“Ù}Œ®ŒŞ ªÀ&säï×tuïÓ“‰I‘ñÍİÉÚüØ-›<Ìr‡~?ºÂı¸Ì¢h°`*°İ™:.s_°'Ü€~íğ/Øps™èÁÒPbGËÃ©zÙX*ù÷ÇV¼Q-wÜÎ^m5Ğ?­f@ô2ï:ï‰ ıè¾„>{¯*z8œ,Y%|7=£•ì¾©Õ6İ­óp&LK¹PdÌ€µËL°ÄZ·Çõzã¯ífş¾Ùä ô&À™3®ïn0˜úÕà¼ów×Êúî¿Õ6§GüœSÜÎ†QøŸnù
!DÈæè^/ƒĞ[i%6î‹±ÚëCŒƒüI–5‚uÒú î?'÷ñÄ¨?>32*‹.3­“˜ßØû\3­ÙÖÃQş›EÛâÅ‘5¾ÍÕàwâ[¢“ø_˜B§şƒ{¾È?r,,š¿¦#•1È¡«Á¨7t8ågÁq¿ûä”¸ÒÔA Ç}¸ä€^k4^ØÜT}²ö®:z·YûSÇ[Åî»ÈïÍ5|q ¸µ5òòµüµbx¸9òúz:îüz³Å¨)™+6~Lİl¿ »»>‡c¤A,léQÒG?1t"µ.tÃÇ
×]XA;*Fu##9{–[º³Ó=İ1º N‡†Pµwe	JšGNzÁSÉ°g1²¸êßUŒm2‹B¡©Dš7—»ššŸicß#ÏA!ò{÷½ÉÖªâÀ—¬mÍ‹Ğ¹¿Ú-Äj°İÛŠ~ß¾±ÃñµùAyø5~ó]P·İ×.ËG—¼ô5-‡"$h’ç.íÖúS±¿ÂgåƒV&ÚÕò7á
œYü´vFDp,Ğ¹?f86¶.d¤EäR¹QîdLø[¡o~³2#t©û{pù´÷Up«ÓyúÇLør?ø+RH²«‹„¸Ûİ9wZWíYæwnü®.ŠFh——Äu…záÃM¤ğ%ıG>JT%tÏĞwñøÏ(¯«8¶+¯Šx3ìyHAüöñ?ØèOù¬0Ş`ïn­ûzz)4›	W|<|noœ™:ùz\_‹ÏívÏ‘€´m™ĞU/5Ô…(/Ÿ¬-ˆ½4ä¿r_á«è3öz~i=ŞÄé§²%ùâ*JzHŞ5É†ñ¥eò‘¨v«şà‹¦;Z7äS‡ø1«±ÒÃÊttalÑØ/Şz6æ>¦:ã‘¿ê=¬½¼•¾"6PÙ&l•·LÀ‡)ŸğÚÜ«·#J«GRNt¸­›ö†ıúG•É’Ú?>#µ¿ÖñÌ‡W'7ş×îÍÿï:»ÏåBAŞ°ëßäÂ©òŞGJ í|ô=+–Êqİßáb+ğƒ¾Õ±ÂO×ñ!~İõtwç<YhõïÊ“ï0ÄSm^õ»jò	†'F’ÜÃ?…a²Çëİùn~ÈTş^bENÆ^Û®oj	ÓÜWaŒW<i—Û° ¹7WÃqİÈ—ßúE–D@ËAåÑ×xóßË:m’–d:Ò:kDÉñú»Ñë\¥«Ó~tV~?`(İmºğ hF×&ãDÀ·ÿ®™©}…ñòÅ(kÜ›–îc¸m"mmŞğ`‡#­Hób¼§è¯ı÷×áuó–v0azs!x¡ rƒF81¡#aJ,—{>×gò#a—„³í-wİú¥ÏG]¯ÛÕÏşŒ ©ÉCÎ]</‰põo»–™²=X—Œû[—À¥*UÅón3¨P*ëLh©i..Üé{TÜøØ¤›¥ç5ß¤")³P<ï¦oY‰´kÓÄÆQ‹¶6(ÑÌP9f$kE¤J \Íï“1ÖgBìtãtX}Yä¸hî£’¨D
ä\
ÁLä"ÔÈ±	•w(”zˆyá`4ç‘†î“öær=r*j-ó :ƒcS’PÚ5¹sÄU†uI)¢?Ë×v†b»­Èt4m1Ç–Ë¶	šÅ†©R]_‚ApIÛ€º£uÁÓ(A|{ŠdlLÒŸ<G>áfk}•g"1f‘‘Ÿ2‹¯Ú,v›Q„büWù{iƒàIÌ7FÑ‰ÿÜ­©\GÿvÉtÈÕÈs;¸}|úu	ÎÖı§#ß‹5
2AÓ®ÃšCÛ¿ƒáóóÃ1„¸ôÅªìÇ_t´Š²#wtŞõ¼¥õ‘ç¨:ı:x¡~ùæzX-ıû{¹¤ê*Ç3ôïÈƒIû¿“ÊÔ¿iZês4sZSÒ0}Ìa4ON,f	‘\\Û—íÂÙ±‘³‹k	ß¯Ó<Şğ2@ÄLŠåp©Á¸(á¥ñÑ[PjŞŞb+o0z•èìm+µGˆ­BĞÉç£A4õ¼«pa]&Ò ˆÀô•‚1·<uÿ~,ºrÓ+Z}ljü)kØÔLÜ=÷#Jù+˜İÕ†ëQ$NJ†É9)"Ö£\Gv¥
FÛİ·ÁÃ€ë_ˆïŞÌ¡Ô­/=É®ANE•^ë+Y:}Pd9¹÷= İ3Â³D¹ëP•¯ú
N,!Ú¨ä&LofÄ¥ùLãş6t§ 	/æ¿"6õúO"]2SèÕİÀıQNç Ö¡ûÙÍQ¼ŸÒ¥P|^3ôp³Â·¶úVßBz03Õp~LH)¼º/~05€öûWî<Ğ“[I¿õıë…+a`V&H]†ÀQÎª‹ƒÔ/àgúC%áôÂ;bŞI™ˆû*©ÿÙ¬Š\Ú¨`Òé3£uzŞ-ÁVoçvóä|)†·	]ÎÛµºViÖˆV$r¬ğ> ùñÍA3-öK`:£Á	ˆQó\äÌ¡"Dñ3æe‰Ş(½_İ;“o¿QBÃ§ğG–.ôSß9¥º>ßô¾ÌHa½,ø
<š^.äy_ØG8^MÏ›@‰,¯YªbşwîÒË‘‹µFZŸ#@°´C™]p
ZJÕşÒŠÒ7Ç2Â»­0!¢gë Ûó½w$}½êKxSşoPiùLÊïLı£”[BwÃ²üñ­åĞ¶ L¥ä—º¸ˆ¦·Hmi'îµ.’ê–]ˆõx/^?Òî%zÖ¡:ª¦%Ÿö3£›·şùpÄiR×H«f3Ó-U–™£$ŒÜëÁõÍSzüvî‡r×]P¯nÂ_+Ë+PÜÇ˜‡ÂkS¶±íbÆ‡¯cÈ?ºGä¼öe–Ë—_àO›ïâ	 ş¶.L(Ä{Ø=*Ş ’K—'øC±¦ÃúÎ‰kæã"œ&q hë“ŞSèY¿¥§"ú({¼ÖŒ†Éßp59WÉ¼¥¡‘EfÀèİş¶ğ€o­`É ÿÑÅ)Ì&¤–Û¥s£™
Fî¡ôï+‰Ò|0¶ÔQ{¶ÕÌõÈÚ.Ï%V¬_ã$	¤©ÖFœºÏ6÷D0‡:FÄ¥Ï=à‡¦¤;¥Eõí½ÍÅ×Ÿ)"n½ËC=ª7²“Ç¼ Š›Ş(¤r8¿ˆ”zÈvÅS¦É‡Ëı÷îù™÷zŒå„³õŞX®ùj™/.z¨{Ö>*„ï–±Ù‚Ê–¢ËÓoıÅ³k1Wïu|ç‘:?–riÍå³WONµÖÜëÌ5f	ûÏos)ƒ$Òû_ÙÅ–É‹@€ciÅ?ªH«½ B¨kûRÍ¼k
w'í×Û³öE¥}¬Åô<‡xCŞÔ§åt“İÿ=÷ãø£^QÅTåêÕ(T{yª^;OF<H‡Ü–X¿‡Ïù¸LøĞñÛ£¾À	yó}SŞ–î&z<¡M…IU›§»òæ]ÍÀĞÇÉúË1©ĞTÑµe?é<´èãe
ÒÀ0Ë^yFTI|k°`RÈ6çTyU ô.;ú’	-·/şsÛ”Ä7{r0–9iü”Ò„®‰úÀk¶8cç›nşçü&,4¬><úéKîP<9õØ³qî€ÀÒU´=Şr½ÓNO«g‰ŞÛ®è]ñ*|Ù™üVïú8äLßïhÙÌÙìí…í$Ü›ˆÃÌ
ˆ÷Çs‘IıÉÚÉ-cÉ¤ÎØã5Û–Ä8ãƒ™…q… æOˆ|›Sà““}­æªÑ@‚~Ùî;¬s; 8ù{)}ôpld!AQnÕ
xŒÑ>;¨ t.@2q¥, Eèø;‹ßÓQ­,ŠŠÔseUQå>4??§…“¯¡£äµõSÈó©Aâßø¬¹qïa¹¡üy£…çµÒT
Ñ¶"~*ÂštöÄâ ªär4,ÉÒ¯½÷‡Ê½}©K'@Ş>Y)õ ü>C[ ÁÅZ`T¯m-[Aî8a^A%ÇöŸ“¤7ã´ö¨»´~0S¢Œ°dîÑ¥