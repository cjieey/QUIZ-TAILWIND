/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EventEmitter } from 'events';
import { StringDecoder } from 'string_decoder';
/**
 * Same as StringDecoder, but exposing the `lastNeed` flag on the type
 */
type SD = StringDecoder & {
    lastNeed: boolean;
};
export type { SD, Pipe, PipeProxyErrors };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export declare const isStream: (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
    fd: number;
}) | (EventEmitter & {
    pause(): any;
    resume(): any;
    pipe(...destArgs: any[]): any;
}) | (NodeJS.WriteStream & {
    fd: number;
}) | (EventEmitter & {
    end(): any;
    write(chunk: any, ...args: any[]): any;
});
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export declare const isReadable: (s: any) => s is Minipass.Readable;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export declare const isWritable: (s: any) => s is Minipass.Readable;
declare const EOF: unique symbol;
declare const MAYBE_EMIT_END: unique symbol;
declare const EMITTED_END: unique symbol;
declare const EMITTING_END: unique symbol;
declare const EMITTED_ERROR: unique symbol;
declare const CLOSED: unique symbol;
declare const READ: unique symbol;
declare const FLUSH: unique symbol;
declare const FLUSHCHUNK: unique symbol;
declare const ENCODING: unique symbol;
declare const DECODER: unique symbol;
declare const FLOWING: unique symbol;
declare const PAUSED: unique symbol;
declare const RESUME: unique symbol;
declare const BUFFER: unique symbol;
declare const PIPES: unique symbol;
declare const BUFFERLENGTH: unique symbol;
declare const BUFFERPUSH: unique symbol;
declare const BUFFERSHIFT: unique symbol;
declare const OBJECTMODE: unique symbol;
declare const DESTROYED: unique symbol;
declare const ERROR: unique symbol;
declare const EMITDATA: unique symbol;
declare const EMITEND: unique symbol;
declare const EMITEND2: unique symbol;
declare const ASYNC: unique symbol;
declare const ABORT: unique symbol;
declare const ABORTED: unique symbol;
declare const SIGNAL: unique symbol;
declare const DATALISTENERS: unique symbol;
declare const DISCARDED: unique symbol;
/**
 * Options that may be passed to stream.pipe()
 */
export interface PipeOptions {
    /**
     * end the destination stream when the source stream ends
     */
    end?: boolean;
    /**
     * proxy errors from the source stream to the destination stream
     */
    proxyErrors?: boolean;
}
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
declare class Pipe<T extends unknown> {
    src: Minipass<T>;
    dest: Minipass<any, T>;
    opts: PipeOptions;
    ondrain: () => any;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
    unpipe(): void;
    proxyErrors(_er: any): void;
    end(): void;
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
declare class PipeProxyErrors<T> extends Pipe<T> {
    unpipe(): void;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
}
export declare namespace Minipass {
    /**
     * Encoding used to create a stream that outputs strings rather than
     * Buffer objects.
     */
    export type Encoding = BufferEncoding | 'buffer' | null;
    /**
     * Any stream that Minipass can pipe into
     */
    export type Writable = Minipass<any, any, any> | NodeJS.WriteStream | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
    /**
     * Any stream that can be read from
     */
    export type Readable = Minipass<any, any, any> | NodeJS.ReadStream | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    });
    /**
     * Utility type that can be iterated sync or async
     */
    export type DualIterable<T> = Iterable<T> & AsyncIterable<T>;
    type EventArguments = Record<string | symbol, unknown[]>;
    /**
     * The listing of events that a Minipass class can emit.
     * Extend this when extending the Minipass class, and pass as
     * the third template argument.  The key is the name of the event,
     * and the value is the argument list.
     *
     * Any undeclared events will still be allowed, but the handler will get
     * arguments as `unknown[]`.
     */
    export interface Events<RType extends any = Buffer> extends EventArguments {
        readable: [];
        data: [chunk: RType];
        error: [er: unknown];
        abort: [reason: unknown];
        drain: [];
        resume: [];
        end: [];
        finish: [];
        prefinish: [];
        close: [];
        [DESTROYED]: [er?: unknown];
        [ERROR]: [er: unknown];
    }
    /**
     * String or buffer-like data that can be joined and sliced
     */
    export type ContiguousData = Buffer | ArrayBufferLike | ArrayBufferView | string;
    export type BufferOrString = Buffer | string;
    /**
     * Options passed to the Minipass constructor.
     */
    export type SharedOptions = {
        /**
         * Defer all data emission and other events until the end of the
         * current tick, similar to Node core streams
         */
        async?: boolean;
        /**
         * A signal which will abort the stream
         */
        signal?: AbortSignal;
        /**
         * Output string encoding. Set to `null` or `'buffer'` (or omit) to
         * emit Buffer objects rather than strings.
         *
         * Conflicts with `objectMode`
         */
        encoding?: BufferEncoding | null | 'buffer';
        /**
         * Output data exactly as it was written, supporting non-buffer/string
         * data (such as arbitrary objects, falsey values, etc.)
         *
         * Conflicts with `encoding`
         */
        objectMode?: boolean;
    };
    /**
     * Options for a string encoded output
     */
    export type EncodingOptions = SharedOptions & {
        encoding: BufferEncoding;
        objectMode?: false;
    };
    /**
     * Options for contiguous data buffer output
     */
    export type BufferOptions = SharedOptions & {
        encoding?: null | 'buffer';
        objectMode?: false;
    };
    /**
     * Options for objectMode arbitrary output
     */
    export type ObjectModeOptions = SharedOptions & {
        objectMode: true;
        encoding?: null;
    };
    /**
     * Utility type to determine allowed options based on read type
     */
    export type Options<T> = T extends string ? EncodingOptions | ObjectModeOptions : T extends Buffer ? BufferOptions | ObjectModeOptions : SharedOptions;
    export {};
}
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export declare class Minipass<RType extends unknown = Buffer, WType extends unknown = RType extends Minipass.BufferOrString ? Minipass.ContiguousData : RType, Events extends Minipass.Events<RType> = Minipass.Events<RType>> extends EventEmitter implements Minipass.DualIterable<RType> {
    [FLOWING]: boolean;
    [PAUSED]: boolean;
    [PIPES]: Pipe<RType>[];
    [BUFFER]: RType[];
    [OBJECTMODE]: boolean;
    [ENCODING]: BufferEncoding | null;
    [ASYNC]: boolean;
    [DECODER]: SD | null;
    [EOF]: boolean;
    [EMITTED_END]: boolean;
    [EMITTING_END]: boolean;
    [CLOSED]: boolean;
    [EMITTED_ERROR]: unknown;
    [BUFFERLENGTH]: number;
    [DESTROYED]: boolean;
    [SIGNAL]?: AbortSignal;
    [ABORTED]: boolean;
    [DATALISTENERS]: number;
    [DISCARDED]: boolean;
    /**
     * true if the stream can be written
     */
    writable: boolean;
    /**
     * true if the stream can be read
     */
    readable: boolean;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args: RType extends Buffer ? [] | [Minipass.Options<RType>] : [Minipass.Options<RType>]);
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength(): number;
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding(): BufferEncoding | null;
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc: BufferEncoding | null);
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc: Minipass.Encoding): void;
    /**
     * True if this is an objectMode stream
     */
    get objectMode(): boolean;
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om: boolean);
    /**
     * true if this is an async stream
     */
    get ['async'](): boolean;
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a: boolean);
    [ABORT](): void;
    /**
     * True if the stream has been aborted.
     */
    get aborted(): boolean;
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_: boolean);
    /**
     * Write data into the stream
     *
     * If the chunk written is a string, and encoding is not specified, then
     * `utf8` will be assumed. If the stream encoding matches the encoding of
     * a written string, and the state of the string decoder allows it, then
     * the string will be passed through to either the output or the internal
     * buffer without any processing. Otherwise, it will be turned into a
     * Buffer object for processing into the desired encoding.
     *
     * If provided, `cb` function is called immediately before return for
     * sync streams, or on next tick for async streams, because for this
     * base class, a chunk is considered "processed" once it is accepted
     * and either emitted or buffered. That is, the callback does not indicate
     * that the chunk has been eventually emitted, though of course child
     * classes can override this function to do whatever processing is required
     * and call `super.write(...)` only once processing is completed.
     */
    write(chunk: WType, cb?: () => void): boolean;
    write(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): boolean;
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n?: number | null): RType | null;
    [READ](n: number | null, chunk: RType): RType;
    /**
     * End the stream, optionally providing a final write.
     *
     * See {@link Minipass#write} for argument descriptions
     */
    end(cb?: () => void): this;
|İr)Ëºõü£ÿCüÌahİîIä<{J“’|"£&)kÛq ƒÜC´ şmí!\e‹ú'öÛo"°)	Ãà€õ¦Ò@çšó_Ôµù¨µ#Ì–é`$Y=¬¡MÚ“¾—&!ZÎ¼³Y~ØøÎ|Íq=µÏÛí´é@–Ñyu‚Éí`»<.9¸ú‹ùñdÌªj{Y—„Ğ¾°Ò;ÁÏÛ®%RçœÇ3íšCY×Î«.ÑV×Pˆ¨ôi]·Q€nßí{'Ò/µ;—ßÊĞJ{¢‚şt°“2/CÜ®Öè¡ÃÉ†½ÛM+Ë{1qÿº&é¯Êo2ã«™õ;ÇÜò}÷Úxl{•^¼WÖìÍİ\Á•J®
¥«ƒ»ºm»>©]QFl;Ÿà98·—ÀªE²J’§S6–ãÎù=Ø¥ôİø¹_EjÑ-ó—7e^ò,«äúø½ò_«Ÿv]ªfí¥ƒeêó Á	…š‘Bš7‡WÔLÊs¸
îÓò
Fº¯}ÏÈqû…E¤Ô2DÉ½Æé"D÷¦x—-€é@ÔôÛß»yt™§êû×Ùlağ{ªëïö1kD-±ä(RüJ6Æj4_ñ|©V›ªÑ±”ù:d9XyªCƒ9»æ{)Œ
J2M«ÈBšUynİÓ/ï„#¤<t1\F×”Õ@‘¸Ìûşñ+Ö½#'¶…{Ïp;ãó’uÚlh †•¡&‹B-ç¯O—¿›H¡ÏQ×yïˆ¤ÒSUKsujÍii]“yÛŞÌ_; O>ş õë’: ­ÎÜ«ğm(ìè·¦74i¥t¢•)D·E tµJÔ[H:û»9?N—e¥ˆ[0Ò‚C §ÑYİcâİx¸ôäycs© æm‹e5@“°Õä4^d§ãü¡_òĞÌÆ†<·}DP›sRf»»ITB‡lÏR\1*»ù†;Beãıu“xfŒqs‡¾ãeª‡‹'H!nÄ2p[š13Q™Rşu˜©–yÎ}ƒ£¥>j2;†m6A6¢}sêßB)xÒ‡_õU-™«´-;¢ñü0õ“q¡ß»#¶Ú)õiµ®ÙdÔ1)^g‡}Gã;	În7/„¡Ô£=¯HğÍY.§Ù@üJu9»rÿŸV^ÙÚ2æ]¬“ãÀE¯v’g“ıÅKÏĞoêºÈÎö$’“•k<%…x2sĞEvàe>‹9'ßçf—c §
*ju¯¦dÅ7)Ó²Ó…'Ó4ÑcàT×ürkKI<(äaƒYVLüag¹@ğ îhhÑ#L–(}O—Íå,!¥'¼6tÕ†„«œdG™ˆğ4Qã«…CÎE~>àkYäİG¸¦u¬`X¥ÛÜ­ 
j½İ6ÇS?<ºÍÄÍ¸ŒJºº2íh„y¾L3
Ør.fìğRˆ´•øLë`~‘B%–»1f¡ú/È&’Vc£4ƒ—ºáè”l"U¦ş"…8Ë§|Kª’áx<š­~ŞıTºXuˆ¤<JrÓsQ¶ÅÆcÙ%¬NË÷ØÎÚbf´~gå¬noÉ÷ ÆÑ5iWŠß*ÏàLÃÉ©Êg¥„ìYd;JÓöŸ³<¨éŠ2ù"ÑO?6Ç_ÁˆÂ®uš| İÒQBÿ©ûµBDS|¯Wz·› ê'JF…¤)‰(6ã°JFU$¡&îşNMñUØù‹h¸Öã<ˆˆ	xofÁì‡g ã‹Í¦cHİÓj;YMĞ5¤p· \ã˜kƒ]Ø«ï(¯^ÉıŒ6ä%0¿p>ê(œ&ë†EQ3Õ#,‰“¶¼
ãÂ5«@8ØôX}r|ãq¸n±F‰Š®£ìé³‘çîÆÓvˆvçÉvæ4í´àV‹¼AÍ¯šŸZŠä3`‰4«¾Ç|¶:d~oÎ8†©YP§£à»à\`5Á‹¨ÛŠH	!7+Pmòi!…÷§dƒ²>ûbÜ•OıöóàêıåÊßEK¯Éò:5…Kí&­¢,ä†ºGñ'°5
… ˆXZ…O–pC4iƒÂ1 ò¯÷h¤qoL‚Û–ÓÖ€³'ùwåT?/¾úüeĞ‹&#ƒşÁ(Dİ„Ó¢fËn=E8a†*S½ø>)á‰ÆñÃCÑj¤Ù…ª©¿“Ù'ñ/ˆiLÕrç¡ëÛ¥ñoR‡ÇFS”j,ªz¯8HDICj†0:¢¸‚ D·ÿG#š/¢§=Z@‚¨ë‚ oÂƒäÀ.ïzßßë¨ôËaÁ]ôÌœÎ,±jtÑ ;!¯æ®²ÏÊ†/úê[±ˆë7€ŞÙdØBƒ÷]ë„dŒ¹¤¡ÌëÂØ™+)xøk«ê×Ùøh0lr¸;!&Î£B Ëö!zoC¯dÀŠ‡q
àB†´E„1È;^º#LÓİje®y[XÙİ$WÉÑÅ$Vk;çcşÎ*\±A˜n[3Ä–"ñ¦VZÈlK’©	¬ÿÎ¥»9Óaì\r|Ü…«3K ™‹F>ÉöJK3Öˆ)!bÒşÄØbú±Ç™5{N’ğÖ9€z¤%„Øú~7®Á¬J æ3[œ‡Ö‡¢›'cŒWO y#D½WÃoRËµ8º?³º­/­OÅá°’ÅÎšB:ƒÆ|y›éß&
9•·V¾ÏÍ•vfå³“MûO`y1ğ”«‹È/úÓj,ò$êš›Ó<×è!¸ì}Ş|†ûõi<¥qHOƒRR%4öÛj[ªWşo­d¾óoà95UÇàJeä>¿kÍ×GTˆ¶».ªàÚMÆ8õ+“Ü¤Wæ IMçËOª}-ùÔ»uLËÏxQšNŒ-Ğı`ï‰A!ºàšùÈáèÚÈ–c7¼<|Ùz(é÷¬ú5P6b{ÿlK»a(†Pcÿè›aQ]rhgŠ·L3Ïb¨gRÄ˜7íóÍ¸+#ŠõŞ©X›%WødEÄ¬Í›=BË`èEâ3é|ÉV' ÚKÖƒ œklØL@Ne!ì®Ó˜p:¸ú=#­ÉaöìåcÂíZÀâäŠÎÖ¶òÓ\¼\«¢ã}~c?QG-È	è•RGÚMT’Y±s	ÕE”@‚½™Ù }|>+È[“tâ‡{6%üà5-Ç(Ô­a8{_ )Sì”×»½”	²j)Ññ‰gl	û3÷ùFàU²	 &sxHĞ“ï£s«İpá	'Û8XÔ¿ú©Ä,¯9´ZŒ«¬GËZë«ëª8iø²şÒ·­HQİ‘µ¹ëã2¢	}õØùˆ^+3ÉŠƒZ.Í¢PA!"¡B¯£ì®£”g'¯ÌÒøF/ÓÍQ~ˆ»7¼¹ Í,´È‹¾7‹hGÔâ8Ê!E=Lí\ŒK+MìMí˜ÛÈ?:"
 µ8aK_——2}Š´DjÊaY"Çf®O3A”òäş‚„™oj!HaãP ]m24)Ìl| <ØgG¶µš«‚Ó'
›`ş‹ğÌŞb‘ù®¥áLkW•é•ü¯‡q¶¡Æäbƒ	cgZò¸M½Şÿ›éÕfû—fP4×ÄßÉgƒöf‚¯èQxÿ×Ñl‚æÅŸr…Cù¼¾0ó9­âÒ3§Ÿ~ôßhœ¸¿*ÒjÏO€üä]¿cQ Ù†-T½oUÏœ÷j`3å·~÷İ20ˆAÒbeê–QCoC²ß-Ö´¼ZøubÌ@y‘ç,~g½ÀF¯ßéêI]µíŒ65dšìîh¢û·..ÎÆÊp^ş¦?ç¤—Ø4ËşoO˜ˆ	tÂøn7Î§ŒN9§êú
%Y´ıÍ,›öÏÆaÿ“%5‚_…|7ËıW¿ ¢´,Ü±y¸Òır‹—O‰¡9Õğ"4°J{0pÄ–9á^í±L°(£Tì~Xc¡¸¡A,@íòEÁJ}ÊSØÂ-ëÅïJÉˆò¼Uµó¡ÂÄ½yJİÂ„o¨ãøè|²4tºQñjC_¾ê.Ô±Cÿáo{›²Í±ë–ºÂĞ‹¦wì¸y [L(T ¯GóÖüÔxu£>Lıö+‘ÊNİa¯ò’oñèiŞúºğ²<æŞOå«]Ó­L=Ê›mÅ5Õ¬j5ã¼ÏaƒØ9f«—JaÙÁ²åÊÁ$8yÊËjú —>†Ía@J¹Ã´bÖÎ™ø'ó€+Şö
rnáÃõx"M¸áßr/g0ff†JG²RG´å\¡µÆï<˜(%,é_‡_º)»ËŞ©vy[1¢MÌâœÇ3Şq8¿|&†•Ñ)"Z4KSá|6“Sõ3‘7\öšÎÇ§bh¤:‘8ÕuÇfŸ›äøÈ€ €(À±äqg0A¼ÛZÎˆ²ŞH:€<Ë³Œ!ê9aÚÁ®×LwñİÛp^2Vşİ×>e9ªúÜÕ§şg Ê.Y\@>ıìµ&ÃAD„ÆxÜ¼İP—FÈb-„2uéé·¾¿ôÔûr€ÇªP‚ˆ©á.ArÀìÆfĞXN™ØRS¼+Üô)¢ÿ¢ccù|ÎGÇØ„b…N):¹k‘-Šœñûš‚pê‚0ç¤Åü"Kç³‡ôFåKÎ»f“íüœ9úÊTùÔı.èaÉcb<tp¢æ0ãÜ£´¤¼M¼2è5•€ñ–Ì(Ø},/?(îLc'›,xşdnçß^ š~‹]N*RÃŠ/pÂú•ûsm§…b¼GÌDx:ÜµÒ¨µ2?Ä‹Éaİ»x
ÔüNÙ˜QÍ¢Ç³l&²LÇŠ·˜ûRCZÕƒwü»æxBMDœÑyå‚V+	>ÏÄÖ¯ÈPg¼£ò%£aÛòóãpË*—nRFP%{MæBòTßÚ†ô0DÊÑ=Î¦èÈ½¯Ü¿—¾^VV/²8ôŒ©®©‘s†s7ñ„*ÆÁç‰cŠ­¿!`GğIøƒ6Í¿mşÆĞíU«ãêC•QÕ±Ê¹h7q†…“
Æ—,-”K§ Î‹ú|ä·µ7bò¾ìzë.iV‚ÖŞ•¤ƒNi~‡ü]ÁÏ+[tiT—Ö³L‘ÿ;Ò´šg‘œ²ş–.Ğ×VgÈZ1¬­ï”ãÂ‹a¬Ş	³ ‘@(*…MÔ>‰÷F†v	 èŒ¾¾¨Î L§ÉÂuFçIMR_QÅµlÏ»“£Bª¼ö¾Ğ„˜¼ìôğì<š#,ïÇû<î"ƒ¹1–6
­‰“¥ùX ìÎ‹ˆİß¬ÑôÄD/ÍW,aìaûGÛŞ"·
3Ñjh‘U’¾D¿ÎóİÂ¾û®s°Fú_Ë&Ù4îgO9Î¦‡R×?ÙÊÇ*ë‰Kª@²%šVWCÃûÓ"Ëz³«‚<¦¹ôeUô_7„ŸØZœˆã‚,ÓŸõ!ÛÙ÷Å7@Àõâ±D(Kşû¢æõVlí¹*®²1&pE5“ßL@Â>ÈÁû[Êí7[YWÂæ¦ÛK_t|‘™«¡¾jÓ$| œÌmßËïCœ¸¿»{|±gô‹îWİ!úD]µçWfäÓªM{Ny—‹`<mP^&q8SºXYûÌ3˜¾;Ë	úÏ»DØîV 	§eX(rFåTbBq’)sö1ÈÆ‘Ù²TÛcpò yşŠD¥UJ»Áaté‰!ˆVŒxùtÎVçQaX VôTo“ø””Æ=T8™|ß°…¨‡8ˆÎ¸
9?…!W:„¬QfÓ*óUÕçP
8³nÉ»lV~çI“	‰EîŸĞ¾‘X,×ù9`”j´k<jpn#Õzk’ó¯Ò1RÙÂI0Ï"ÄLaO‘1pxÏW¡†QØ’|Æâ'¤ŠïÿEé3u:î#v5¦­–×î?6ãóêÑ«·ª>‘¢¯Y„mIÌ´øûøQ‹ç”8€F¬Ên
?ƒDD~ª­QË¤B¼…¥„BÔ3+û$ı@}*½¬ò•¤ ré€¼R|`¹æ2Mãzmµ!ë†^ªåD°]KÉ7œM¢s<|?\ó'x¢²åñhb¶/ã	ù»ù˜€ öÿl^èêì²â¯Bêû™Fs±›OÜ(”È§­vª\ëVeüÏı–6«r?d.˜“Ñ‚xæ_"êF*²aMÓCyÚMs/jÉ¯„%k*¬:Ì¥OØaäãyÔ9xÂ/qòç¨câí\ªÃ‰²#dŸªM£ÑçŸšƒ­,>˜°Àjc•%•ÔxÙ¥ú&Í¼S­kC2ı\°ñŸwï3DVğAªcœ¾ÛYy
JĞA}/zm˜ÀSÿ½F¼eYã2¬V·4ºê}Ç®”~œÚ\H ğ«¸âwò•‰éO?ÖMO[‹.æ$Şœu8{lV•laToŒ$¡ŸÃƒDĞPjÒŸEÎK]\ªéÃ²ğ óŸl\ÈÜ¨dAÀÛ>Õo™'ÃÁÚ¥%ê¨‘[a/^o6¯—…¶ˆ,°Õi€Sû]OJ-Å¾€0G0cµaX%wÆ²Ğ@pŒ•|®!%5d-Vjb¬¯/æãñË›>\âwïejtâf]:}6<J"}ÑÉ¬…!”æ¹¦´İ2kÏö}Ã;ÛUãO[IÑ¯×»EcõÅÜE1Œ¼»+àÉgb({RˆÂĞ©Szo8d°=«¾J,ğ7¿n¾ *ÍlGÛŒè/Eg†Œú:ÙX©ŠşYÏNMÓ½å¢¤ô|œÖÍ`<•L°~ÙqyLÑÎ¹å ƒpüñßX¼,¾cå)zdELÇlâ=œã6°|“£'ä•®/2¾eã_¼Ş"\¯_ºyA³=Ğ§óóµ&Rc£¸£ñ—+Ûrú”`r¨y§«¢ds9ŠĞĞ ĞSjëÍuåË/à u\l7ªğfH•]|s|tÄrúˆĞ2WŒ}§Û1‹Eıq7_^XõäBO`–m¡#m°Ä©ÏÅÁ±kã‹Ü%Ë×-Æáæa¡–YîfUš­®?P2_4cCCX¨ÍÔòš£¡›(¿à&[„Ø£¤ÙõˆÒ÷Î’ğ‡´4Ø¬Êm_/A:å¿ØuÁ¨¥Òo/këü§|ugè½Ì}O¿ÕÁ½ZØ€uWFN(ô;¾¿iïUïR[wDÆ3ö§f×zçy3a_rôßÙŠ¬´¹jT´rá³f Bİ¢H:ˆ.ôºÏ/X;8AØKâ[üvº©ê¡ı¡r¯I*RxÄÇiÉtê÷BŒ¶ó²ï6Ó’x‰l[ú¯ÙåÒı ½ÈÅòS­¹2Ÿ¢UªtlX(ú›¾
Aœ·¥¨z–×tƒÁKû$ŒÕ‹ÒLÊQÄÂÖğ(ö£ç ùÁˆ$¿ù©×¢ÑŒ¹¹q½¿…<j2ïˆLï}ÕÎAVGAt6‘LÕèğı²ÆŒ£Å/¨í¶šñü’z»<…§Æ
rµUŞß'ÇÊxDğM7Àv¸FõÃ€«ô8¦à+fhQ	ÆSL‰)¾î†à2ûóæßI«:8Ş—ÃKİ¶˜ÒJ+@©wŠBLĞ[Ü!X¨¬¢C~d„ú¼7­¾ç´R–°^…O:]I]ÙUÆhzVã–É£ağ<ŒÁßKÁ­B2ğL³ˆrº“7H+ƒN?‡¹‰Á‚•0µ³-óÄœ$ü¯â”6¹ÁÖyA„NJj¿õÍsW™s`á¿58;ø$_IÉúS·¡&ßˆ(Ïƒú»‚½	”ûd nõYT2¯’GŞp:è(qU
Şš¦-P-û%÷^(—¬¥
˜$XÄàGjğQêÜ1PtŸô0Lüx¹¿cÁºá¡•¢–îÕ¿æÎ‘	ÿñ=ù)"PÎúÍxæ=t+ºwhƒn2v½ÕÒUAZ´™1}ºâ4.åC]c² %~%e&Rl<Èj¶}ÁÊõ4*Öt#qn#Am©²¹*œaMzebNzœ+
B™÷”A®2¾ğ_ó±›ä«Ä£­:HH™;j¨û1¹Ç¾¦ˆqÕ«*Ğ0¼³@ãÈ²²z;*†Ïùx²b2UN@ˆÅcˆÓ£ôî*êÏ}†ƒrÃşû»X9@n"#`²ÎŠá„J^’¤$ä$äïZ®b*ºÙn+4yµ+¤™”6OŠ!FEÎewsìGØ1=½uyíÔ$Ñ:ñµ¥ë!è³Â8Ee[fÊí‹¼¯ù-VÊ|è`n[á4ÔÓŸSÊ|(>ğÉ:hŞ—™MõºÚh]?}N&íĞ%¦HğçªE.V¿_w¿ø‹¼7!_PÙ-fïàâú4ç¥ø¥Ìœñ³ÊriDc
ÆÑ$y¸ÒmZ¤‡úYNséBnKm
†ŞÜÚÇvb=Zvïı°G£|ƒÏïOÑÂ¢ÙÃè½È\¯U[¸–Ì/)ñ™xÕ.wr›îßÌ¨tÃMR?ÍŸ Çb®û»¤|o‰3»%éqAÿ›õ„añs¨KÈ104Fíï„¸´Ô¡œ“a™b·.H•áóÑÚÃÎŸ•ü¤Ú×	óıŠsµ§¼˜d{­şÊàåcL]]é¤²¹yw%×òƒ»şï$½äñÌ©ïòJR}pa¯‡GeÄ§ü—éâiº©tĞşö"ÀÍOD<éNĞx`´‡ï§ ¯¬	å…O*ô»%c_ÄÀëO¨4ãY¡T'câÇş#õ2(márvÔˆ @¬¼·!äœŞÔªøtåÈ&2øN;fGİÀÁ>ŸP¡Æ§*Å/0Õ¥l¦†>A×ã<tu"8¿œŸÈİD‡û¯úÂGëŸªnIí£v;ŸvÑqJ?Üâ•ZĞ8¦Ê€)å±¹Ã‡şÈëéf¿ŸÎÜ®ı¹·—Üùs?J‰±öÛÿHæ«_†”Ëı¸eœû»êM4È¸ôu÷Ş_>!BµBaóFi Ózğ‘Áèo<E\3±ÓÛ‰9Œo½µ¦ß96îf.ã¨í8ÃÉí”&?‘d©âÌ³­.”½sã²na’?I…”BJ™ŠıíÉc\*;"ÑöS¦é¤¤‚“Fõ< e`ÛãÔk£R*Ä—ª¡†²î3ôÜã&7«Ç©h-*õP±µ‘|i¿î½¯²Õ›UÌ?ÙG4:âZïáÛ x×dÛUäÃw™í“¬úö9ánhÅ"œ3ônŞ|,w?‹;×|¿‡ÑÀ—d1µ„(xß˜G–Ãy NZšı‹¥º°˜×şÅ¿KD3w£lGôÒî4§?‰.‡Š¤*«ƒ´yà›ò%JÇ!¢ì…Hƒ¾ã^3ğaøTø¥Š~ë•7õ-¯››GÌ¿5œ~+ÙL,h^ã˜ ¤\A°
øÁ“á=2ÕiaÈ·_M§ê¿H×ôFå?ã‚TÀ÷7îÜÈº·ÙG#–ô94É?¶v3‡Â?ÎVçı¬+p·«GF,‘Á¬ª–$êÂ™2*½Ù‹í=CI„UİÊL9>Ê9'&}xl§Shõ½?hF"ÈH"ÌÚ@